{
  "Makefile": "NAME = cub3d\nCC = gcc\nCFLAGS = -Wall -Wextra -Werror #-g -fsanitize=address\nRM = rm -f\n\nSRCS =\tmain.c \\\n\t\tlogic_parsing/check_args.c \\\n\t\tlogic_parsing/fetch_map.c \\\n\t\tlogic_parsing/map_config_fc.c \\\n\t\tlogic_parsing/map_config_tex.c \\\n\t\tlogic_parsing/map_data.c \\\n\t\tlogic_parsing/map_data_helper.c \\\n\t\ttools/strings/strings1.c \\\n\t\ttools/strings/strings2.c \\\n\t\ttools/strings/strings3.c \\\n\t\ttools/get_next_line.c\n\n\n\n\nOBJS = $(SRCS:.c=.o)\n\nall: $(NAME)\n\n$(NAME): $(OBJS)\n\t$(CC) $(CFLAGS) -o $(NAME) $(OBJS) \n\n%.o: %.c cub3d.h\n\t$(CC) $(CFLAGS) -I. -c $< -o $@\n\nclean:\n\t$(RM) $(OBJS)\n\nfclean: clean\n\t$(RM) $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re\n",
  "cub3d.h": "#ifndef CUB3D_H\n#define CUB3D_H\n# ifndef BUFFER_SIZE\n#  define BUFFER_SIZE 42\n#endif\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <limits.h> \n#include <string.h>\n\ntypedef struct s_gc_node\n{\n\tvoid\t\t\t\t*pt;\n\tstruct s_gc_node\t*next;\n}\tt_gc_node;\ntypedef enum e_co_type\n{\n    NO,\n    SO,\n    WE,\n    EA,\n    F,\n    C\n} t_co_type;\n\ntypedef struct s_color\n{\n    int r;\n    int g;\n    int b;\n    int rgb;\n}   t_color;\ntypedef struct s_textures\n{\n    void    *img_ptr;\n    char    *addr;\n    int     bpp;\n    int     line_len;\n    int     endian;\n    int     width;\n    int     height;\n    char    *path;\n}   t_textures;\ntypedef struct s_config\n{\n    t_textures  no_tex;\n    t_textures  so_tex;\n    t_textures  we_tex;\n    t_textures  ea_tex;\n    t_color     f_color;\n    t_color     c_color;\n    int         all_done;\n    t_co_type   type;\n} t_config;\ntypedef struct s_game\n{\n    void        *mlx_ptr;\n    void        *win_ptr;\n    t_textures  img_buffer;\n    t_config    config;\n    char        **map;\n    size_t      map_width;\n    size_t      map_height;\n    int         map_started;\n    int         map_closed;\n    int         player_count;\n} t_game;\n\n\nint     ft_strcmp(const char *s1, const char *s2);\nvoid    free_split(char **arr);\nchar\t*get_next_line(int fd);\nchar\t**ft_split(char const *s, char c);\nchar\t*ft_strjoin(char const *s1, char const *s2);\nint     ft_strcmp(const char *s1, const char *s2);\nint     ft_strncmp(const char *s1, const char *s2, size_t n);\nchar\t*ft_strdup(char *value);\nsize_t  ft_strlen(const char *s);\nchar\t*ft_substr(char const *s, unsigned int start, size_t len);\nint     ft_atoi(const char *str);\nchar\t*ft_strchr(const char *s, int c);\nchar    *ft_strtrim_newline(char *s);\nint     ft_isdigit(int c);\n\n// map checking and parsing --------------------------------\nint     pre_check(int ac, char **av);\nint     main_trigger(char *map, t_game *game);\nint     process_tex(char **tex_tokens, t_config *config, int *current_line_done);\nint     process_fc(char **fc_tokens, t_config *config, int *current_line_done);\nint     is_player_char(char c);\nint     process_map(char *line, t_game *game);\nint     check_map_closed(t_game *game);\nint     is_empty(char *line);\n\n#endif",
  "main.c": "#include \"cub3d.h\"\n\n\nint main(int ac, char **av)\n{\n    t_game  game;\n\n    memset(&game, 0, sizeof(t_game));\n    if (!pre_check(ac, av))\n        return (0);\n    if (!main_trigger(av[1], &game))\n        return (0);\n    \n}",
  "logic_parsing/check_args.c": "#include \"cub3d.h\"\n\nstatic int is_valid_file(char *fname)\n{\n    char *ext;\n\n    ext = ft_strchr(fname, '.');\n    if (!ext || ft_strchr(fname, ' '))\n        return (0);\n    if (ft_strcmp(ext, \".cub\") != 0)\n        return (0);\n    return (1);\n}\n\nint pre_check(int ac, char **av)\n{\n    if (ac != 2)\n    {\n        printf(\"ERROR\\nFew arguments!\\nUsage: ./cub3d [./path_to_the_map_file]\\n]\");\n        return (0);\n    }\n    if (!is_valid_file(av[1]))\n    {\n        printf(\"ERROR\\nInvalid map file!\\n\");\n        return (0);\n    }\n    return (1);\n}\n",
  "logic_parsing/fetch_map.c": "#include \"cub3d.h\"\n\nstatic int process_config_line(char **s_line, t_game *game, char *line)\n{\n    int current_line_done;\n\n    current_line_done = 0;\n    if (ft_strcmp(s_line[0], \"NO\") == 0 || ft_strcmp(s_line[0], \"SO\") == 0 ||\n        ft_strcmp(s_line[0], \"EA\") == 0 || ft_strcmp(s_line[0], \"WE\") == 0)\n    {\n        if (!process_tex(s_line, &game->config, &current_line_done))\n            return (0);\n    }\n    else if (ft_strcmp(s_line[0], \"F\") == 0 || ft_strcmp(s_line[0], \"C\") == 0)\n    {\n        if (!process_fc(s_line, &game->config, &current_line_done))\n            return (0);\n    }\n    else\n    {\n       if (process_map(line, game))\n       {\n            if (game->config.all_done < 6)\n                return (printf(\"Error\\nmap data found before or within the map config\\n\"), 0);\n       }\n       else \n       {\n            if (!game->map_started)\n                printf(\"Error\\nInvalid texture identifier: %s\\n\", s_line[0]);\n            return (0);\n       }\n    }\n    if (current_line_done)\n    {\n        game->config.all_done++;\n    }\n    return (1);\n}\nstatic int ft_isspace(char c)\n{\n    return (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == '\\v');\n}\n\nint is_empty(char *line)\n{\n    if (!line)\n        return (1); \n    int i = 0;\n    while (line[i])\n    {\n        if (!ft_isspace(line[i])) \n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nstatic int parse_line(char *line, t_game *game)\n{\n    char    **tokens;\n\n    if (is_empty(line))\n    {\n        if (!game->map_started)\n            return (1);\n        else if (!game->map_closed)\n            return (printf(\"Error\\nfound an empty line inside map data.\\n\"), 0);\n    }\n    tokens = ft_split(line, ' ');\n    if (!tokens)\n        return (printf(\"Error\\nft_split failed\\n\"), 0);\n    if (!process_config_line(tokens, game, line))\n            return (free_split(tokens), 0);\n    free_split(tokens);\n    return (1);\n}\n\nint main_trigger(char *map, t_game *game)\n{\n    int     fd;\n    char    *line;\n    char    *trimed_line;\n\n    game->config.all_done = 0;\n    game->map_started = 0;\n    game->map = NULL;\n    game->map_width = 0;\n    game->map_height = 0;\n    game->map_closed = 0;\n    fd = open(map, O_RDONLY);\n    if (fd < 0)\n        (perror(\"open\"), exit(EXIT_FAILURE));\n    line = get_next_line(fd);\n    while (line != NULL)\n    {\n        trimed_line = ft_strtrim_newline(line);\n        if (!trimed_line)\n            return (printf(\"ERROR\\nstriming line failed!\\n\"), free(line), close(fd), 0);\n        if (!parse_line(trimed_line, game))\n            return (free(line), free(trimed_line), close(fd), 0);\n        free(line);\n        line = get_next_line(fd);\n    }\n    close(fd);\n    if (game->config.all_done == 0 && !game->map_started)\n        return (printf(\"map file cannot be empty!\\n\"), 0);\n    if (game->config.all_done < 6)\n        return (printf(\"Error\\nMissing one or more config id.\\n\"), 0);\n    if (!game->map_started)\n        return (printf(\"Error\\nmap data wasn't found in file\\n\"));\n    if (check_map_closed(game))\n        return (0);\n    return (1);\n}\n",
  "logic_parsing/map_config_fc.c": "#include \"cub3d.h\"\nstatic t_color get_representation(char **tokens, int *line)\n{\n    t_color c;\n    int     r;\n    int     g;\n    int     b;\n\n    memset(&c, 0, sizeof(t_color));\n    r = ft_atoi(tokens[0]);\n    g = ft_atoi(tokens[1]);\n    b = ft_atoi(tokens[2]);  \n    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 )\n    {\n        *line = 0;\n        return (printf(\"Error\\nrgb is out of range.\\n\"), c);\n    }\n    c.r = r;\n    c.g = g;\n    c.b = b;\n    c.rgb = (c.r << 16) | (c.g << 8) | c.b;\n    return (c);\n}\nstatic void    fill_color(t_config *config, t_co_type type, char **rgb_tokens, int *line)\n{\n    t_color tmp_color;\n\n    tmp_color = get_representation(rgb_tokens, line);\n    \n    if (type == F)\n        config->f_color = tmp_color;\n    else    \n        config->c_color = tmp_color;\n    if (line == 0)\n        return;\n}\n\nstatic int not_valid_num(char **rgb)\n{\n    int i;\n    int j;\n\n    i = 0;\n    j = 0;\n    while (rgb[i] != NULL)\n    {\n        while (rgb[i][j])\n        {\n            if (!ft_isdigit(rgb[i][j]) && rgb[i][j] != ' ')\n                return(printf(\"Error\\nInvalid rgb representation: %s\\n\", rgb[i]), 0);\n            j++;\n        }\n        i++;\n        j = 0;\n    }\n    return (1);\n}\nstatic char *join_tokens(char **tokens)\n{\n    char *result;\n    char *tmp;\n    int   i;\n\n    if (!tokens || !tokens[0])\n        return (NULL);\n    result = ft_strdup(tokens[1]);\n    if (!result)\n        return (NULL);\n    i = 2;\n    while (tokens[i])\n    {\n        tmp = ft_strjoin(result, \" \");\n        free(result);\n        if (!tmp)\n            return (NULL);\n        result = ft_strjoin(tmp, tokens[i]);\n        free(tmp);\n        if (!result)\n            return (NULL);\n        i++;\n    }\n    return (result);\n}\n\nint process_fc(char **fc_tokens, t_config *config, int *current_line_done)\n{\n    char *merged;\n    char **rgb;\n\n    *current_line_done = 1;\n    if (!fc_tokens[1])\n        return (printf(\"Error\\nMissing rgb representation for %s...\\n\", fc_tokens[0]), 0);\n    merged = join_tokens(fc_tokens);\n    if (!merged)\n        return (printf(\"Error\\nmalloc failed\\n\"), 0);    \n    rgb = ft_split(merged, ',');\n    free(merged);\n    if (!rgb)\n        return (printf(\"Error\\nft_split failed!\\n\"), 0);\n    if (!not_valid_num(rgb))\n        return (0);\n    if (!rgb[0] || !rgb[1] || !rgb[2] || rgb[3] != NULL)\n        return (printf(\"Error\\ninvalid rgb representation\\n\"), 0);\n    if (ft_strcmp(fc_tokens[0], \"F\") == 0)\n        fill_color(config, F, rgb, current_line_done);\n    else if (ft_strcmp(fc_tokens[0], \"C\") == 0)\n        fill_color(config, C, rgb, current_line_done);\n    if (!(*current_line_done))\n        return (0);\n    return (1);\n}\n",
  "logic_parsing/map_config_tex.c": "#include \"cub3d.h\"\n\nstatic t_textures get_texture(char **tex_tokens, int *done)\n{\n    t_textures  t;\n    int         fd;\n    char        *raw_path; \n\n    memset(&t, 0, sizeof(t_textures));\n    if (!tex_tokens || !tex_tokens[0] || !tex_tokens[1])\n    {\n        *done = 0;\n        return ( printf(\"Error\\\\nInvalid texture line format. Expected 'IDENTIFIER PATH'.\\\\n\"), t);\n    }\n    raw_path = tex_tokens[1];\n    t.path = ft_strdup(raw_path);\n    if (!t.path)\n    {\n        *done = 0;\n        return (perror(\"Error\\\\nMalloc failed for texture path\"), t);\n    }\n    fd = open(t.path, O_RDONLY);\n    if (fd < 0)\n    {\n        *done = 0;\n        return (perror(\"Error\\\\nCannot open texture path\"), t);\n    }\n    close(fd);\n    *done = 1;\n    return (t);\n}\nstatic void    fill_config(t_config *config, t_co_type type, char **tex_tokens, int *current_line_done)\n{\n    t_textures temp_tex;\n\n    temp_tex = get_texture(tex_tokens, current_line_done);\n    if (*current_line_done == 0)\n        return;\n    if (type == NO)\n    {\n        if (config->no_tex.path != NULL) { printf(\"Error\\nDuplicate NO texture definition.\\n\"); *current_line_done = 0; return; }\n        config->no_tex = temp_tex;\n    }\n    else if (type == SO)\n    {\n        if (config->so_tex.path != NULL) { printf(\"Error\\nDuplicate SO texture definition.\\n\"); *current_line_done = 0; return; }\n        config->so_tex = temp_tex;\n    }\n    else if (type == EA)\n    {\n        if (config->ea_tex.path != NULL) { printf(\"Error\\nDuplicate EA texture definition.\\n\"); *current_line_done = 0; return; }\n        config->ea_tex = temp_tex;\n    }\n    else if (type == WE)\n    {\n        if (config->we_tex.path != NULL) { printf(\"Error\\nDuplicate WE texture definition.\\n\"); *current_line_done = 0; return; }\n        config->we_tex = temp_tex;\n    }\n}\n\nint process_tex(char **tex_tokens, t_config *config, int *current_line_done)\n{\n\n    *current_line_done = 0;\n    if (tex_tokens[2] != NULL)\n    {\n        printf(\"Error\\nToo many arguments on texture line '%s %s ...'\\n\", tex_tokens[0], tex_tokens[1]);\n        return (0);\n    }\n    if (ft_strcmp(tex_tokens[0], \"NO\") == 0)\n        fill_config(config, NO, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"SO\") == 0)\n        fill_config(config, SO, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"EA\") == 0)\n        fill_config(config, EA, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"WE\") == 0)\n        fill_config(config, WE, tex_tokens, current_line_done);\n    if (!(*current_line_done))\n        return (0);\n    return (1);\n}\n",
  "logic_parsing/map_data.c": "#include \"cub3d.h\"\nstatic int is_map_char(char c)\n{\n    return (c == '0' || c == '1' || c == 'N' || c == 'S' || c == 'E' || c == 'W' || c == ' ');\n}\n\nint is_player_char(char c)\n{\n    return (c == 'N' || c == 'S' || c == 'E' || c == 'W');\n}\nstatic void add_line(t_game *game, char *line)\n{\n    char    **new_map;\n    size_t  i;\n\n    i = 0;\n    if (!game->map)\n    {\n        game->map = (char **)malloc(sizeof(char *) * 2);\n        if (!game->map)\n            (perror(\"Error\\nMalloc failed for map\"), exit(EXIT_FAILURE));\n        game->map[0] = ft_strdup(line);\n        if (!game->map[0])\n            (perror(\"Error\\nMalloc failed for map line\"), exit(EXIT_FAILURE));\n        game->map[1] = NULL;\n        game->map_height = 1;\n    }\n    else\n    {\n        new_map = (char **)malloc(sizeof(char *) * (game->map_height + 2));\n        if (!new_map)\n            (perror(\"Error\\nMalloc failed for map\"), exit(EXIT_FAILURE));\n        while (i < game->map_height)\n        {\n            new_map[i] = game->map[i];\n            i++;\n        }\n        new_map[i] = ft_strdup(line);\n        if (!new_map)\n            (perror(\"Error\\nMalloc failed for map line\"), exit(EXIT_FAILURE));\n        new_map[i + 1] = NULL;\n        free(game->map);\n        game->map = new_map;\n        game->map_height++;\n    }\n    if (ft_strlen(line) > game->map_width)\n        game->map_width = ft_strlen(line);\n}\n\n\n\nstatic int validate_map_line(char *line, t_game *game)\n{\n    size_t  i;\n    static  int p_count;\n\n    i = 0;\n    while (line[i])\n    {\n        if (!is_map_char(line[i]))\n            return (printf(\"Error\\nInvalid character in map: '%c\\n'\", line[i]), 0);\n        if (is_player_char(line[i]))\n        {\n            p_count++;\n            if (p_count > 1)\n                return (printf(\"Error\\nOnly one player start position is allowed in the map.\\n\"), 0);\n        }\n        if (line[i] == '0' || is_player_char(line[i]))\n        {\n            if (i > 0 && line[i - 1] == ' ')\n                return (printf(\"Error\\n'0' or player character surrounded by space on left.\\n\"), 0);\n            if (line[i + 1] == ' ')\n                return (printf(\"Error\\n'0' or player character surrounded by space on right.\\n\"), 0);\n        }\n        i++;\n    }\n    game->map_started = 1;\n    return (1);\n}\n\nint process_map(char *line, t_game *game)\n{\n    if (!validate_map_line(line, game))\n        return (0);\n    if (is_empty(line))\n    {\n        game->map_closed = 1;\n        return (0);\n    }\n        \n    add_line(game, line);\n    return (1);\n}",
  "logic_parsing/map_data_helper.c": "#include \"cub3d.h\"\n\nstatic int check_column_edges(t_game *game)\n{\n    size_t c;\n\n    c = 0;\n    while (c < game->map_width)\n    {\n        if (c < ft_strlen(game->map[0]) &&\n            (game->map[0][c] == '0' || is_player_char(game->map[0][c])))\n            return (printf(\"Error\\nMap not closed (top edge).\\n\"), 0);\n        if (c < ft_strlen(game->map[game->map_height - 1]) &&\n            (game->map[game->map_height - 1][c] == '0' || \n            is_player_char(game->map[game->map_height - 1][c])))\n            return (printf(\"Error\\nMap not closed (bottom edge).\\n\"), 0);\n        c++;\n    }\n    return (1);\n}\n\nstatic int check_neighbor_edges(t_game *game, size_t *r)\n{\n    size_t  c;\n    char    current_char;\n\n    c = 0;\n    while (c < ft_strlen(game->map[(*r)]))\n    {\n        current_char = game->map[(*r)][c];\n        if (current_char == '0' || is_player_char(current_char))\n        {\n            if (r == 0 || (c >= ft_strlen(game->map[(*r) - 1]) ||\n                game->map[(*r) - 1][c] == ' ' || game->map[(*r) - 1][c] == '\\0'))\n                return (printf(\"Error\\nMap not closed (top neighbor of '0' or player).\\n\"), 0);\n            if ((*r) == game->map_height - 1 ||\n                (c >= ft_strlen(game->map[(*r) + 1]) ||\n                game->map[(*r) + 1][c] == ' ' || game->map[(*r) + 1][c] == '\\0'))\n                return (printf(\"Error\\nMap not closed (bottom neighbor of '0' or player).\\n\"), 0);\n            if (c == 0 || game->map[(*r)][c-1] == ' ')\n                return (printf(\"Error\\nMap not closed (left neighbor of '0' or player).\\n\"), 0);\n            if (c == ft_strlen(game->map[(*r)]) - 1 || game->map[(*r)][c+1] == ' ')\n                return (printf(\"Error\\nMap not closed (right neighbor of '0' or player).\\n\"), 0);\n        }\n        c++;\n    }\n    return (1);\n}\n\nstatic int check_raw_edges(t_game *game)\n{\n    size_t  r;\n    size_t  c;\n    size_t  first_non_space;\n    size_t  last_non_space;\n\n    c = 0;\n    r = 0;\n    first_non_space = (size_t) - 1;\n    last_non_space = (size_t) - 1;\n    while (r < game->map_height)\n    {\n        while (c < ft_strlen(game->map[r]))\n        {\n            if (game->map[r][c] != ' ')\n            {\n                first_non_space = c;\n                break;\n            }\n            c++;    \n        }\n        if (first_non_space != (size_t) - 1 &&\n            (game->map[r][first_non_space] == '0' ||\n            is_player_char(game->map[r][first_non_space])))\n            return (printf(\"Error\\nMap not closed (left edge).\\n\"), 0);\n        c = ft_strlen(game->map[r]);\n        while (c > 0)\n        {\n            c--;\n            if (game->map[r][c] != ' ')\n            {\n                last_non_space = c;\n                break;\n            }\n        }\n        if (last_non_space != (size_t)-1 &&\n            (game->map[r][last_non_space] == '0' ||\n            is_player_char(game->map[r][last_non_space])))\n            return (printf(\"Error\\nMap not closed (right edge).\\n\"), 0); \n        if (!check_neighbor_edges(game, &r))\n            return (0);\n        r++;\n    }\n    return (1);\n}\n\nint check_map_closed(t_game *game)\n{\n    if (!check_column_edges(game))\n        return (0);\n    if (!check_raw_edges(game))\n        return (0);\n    return (1);\n}",
  "tools/get_next_line.c": "#include \"cub3d.h\"\n\nstatic char\t*get_line(char *reserve)\n{\n\tint\t\tstart;\n\tchar\t*line;\n\tint\t\ti;\n\n\tstart = 0;\n\ti = 0;\n\twhile (reserve[i] != '\\n' && reserve[i] != '\\0')\n\t\ti++;\n\tline = ft_substr(reserve, start, i);\n\treturn (line);\n}\n\nstatic char\t*update_reserve(char *reserve)\n{\n\tchar\t*new_res;\n\tint\t\ti;\n\n\ti = 0;\n\twhile (reserve[i] != '\\n' && reserve[i] != '\\0')\n\t\ti++;\n\tif (reserve[i] == '\\n')\n\t\ti++;\n\tnew_res = ft_substr(reserve, i, ft_strlen(reserve) - i);\n\tfree(reserve);\n\treserve = NULL;\n\treturn (new_res);\n}\n\nstatic char\t*helper_func(char *buffer, char *reserve, int fd)\n{\n\tint\tbytes_read;\n\n\tbytes_read = 1;\n\twhile (bytes_read)\n\t{\n\t\tbytes_read = read(fd, buffer, BUFFER_SIZE);\n\t\tif (bytes_read == -1)\n\t\t\treturn (free(buffer), free(reserve), reserve = NULL, NULL);\n\t\tbuffer[bytes_read] = '\\0';\n\t\treserve = ft_strjoin(reserve, buffer);\n\t\tif (!reserve)\n\t\t\treturn (NULL);\n\t\tif (ft_strchr(reserve, '\\n'))\n\t\t\tbreak ;\n\t}\n\tfree(buffer);\n\treturn (reserve);\n}\n\nchar\t*get_next_line(int fd)\n{\n\tstatic char\t*reserve = NULL;\n\tchar\t\t*buffer;\n\tchar\t\t*line;\n\n\tif (fd < 0 || BUFFER_SIZE <= 0 || BUFFER_SIZE > INT_MAX)\n\t\treturn (free(reserve), reserve = NULL, NULL);\n\tbuffer = malloc((size_t) BUFFER_SIZE + 1);\n\tif (!buffer)\n\t\treturn (NULL);\n\treserve = helper_func(buffer, reserve, fd);\n\tif (!reserve || *reserve == '\\0')\n\t\treturn (free(reserve), reserve = NULL, NULL);\n\tline = get_line(reserve);\n\treserve = update_reserve(reserve);\n\treturn (line);\n}\n\n",
  "tools/garbage_collector/gc_mall.c": "#include \"cub3d.h\"\n\nstatic t_gc_node\t**get_gc_head_instance(void)\n{\n\tstatic t_gc_node\t*head;\n\n\treturn (&head);\n}\n\nvoid\tgc_add_pt(void *pt)\n{\n\tt_gc_node\t*new_node;\n\tt_gc_node\t**head;\n\n\tif (!pt)\n\t\treturn ;\n\thead = get_gc_head_instance();\n\tnew_node = (t_gc_node *)malloc(sizeof(t_gc_node));\n\tif (!new_node)\n\t{\n\t\tperror(\"malloc failed in garbage collector\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tnew_node->pt = pt;\n\tnew_node->next = *head;\n\t*head = new_node;\n}\n\nchar\t*gc_strdup(char *str)\n{\n\tchar\t*new_str;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = ft_strdup(str);\n\tif (!new_str)\n\t{\n\t\tperror(\"strdup failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nchar\t*gc_substr(char const *s, unsigned int start, size_t len)\n{\n\tchar\t*new_str;\n\n\tif (!s)\n\t\treturn (NULL);\n\tnew_str = ft_substr(s, start, len);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\tgc_freed(void)\n{\n\tt_gc_node\t*current;\n\tt_gc_node\t*tmp;\n\tt_gc_node\t**head;\n\n\thead = get_gc_head_instance();\n\tcurrent = *head;\n\twhile (current != NULL)\n\t{\n\t\ttmp = current;\n\t\tcurrent = current->next;\n\t\tfree(tmp->pt);\n\t\tfree(tmp);\n\t}\n\t*head = NULL;\n}\n",
  "tools/garbage_collector/gc_mall2.c": "#include \"cub3d.h\"\n\nchar\t*gc_itoa(int n)\n{\n\tchar\t*new_str;\n\n\tnew_str = ft_itoa(n);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\t*gc_mall(size_t size)\n{\n\tvoid\t*pt;\n\n\tpt = malloc(size);\n\tif (!pt)\n\t{\n\t\tperror(\"malloc failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(pt);\n\treturn (pt);\n}\n\nchar\t*gc_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = ft_strjoin(s1, s2);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n",
  "tools/strings/strings1.c": "#include \"cub3d.h\"\n\nstatic size_t\tcount_words(char const *s, char c)\n{\n\tsize_t\tcount;\n\tsize_t\ti;\n\n\tcount = 0;\n\ti = 0;\n\twhile (s && s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tcount++;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\treturn (count);\n}\n\nstatic void\tpopulate_split(char **arr, char const *s, char c)\n{\n\tsize_t\ti;\n\tsize_t\tj;\n\tsize_t\tstart;\n\n\ti = 0;\n\tj = 0;\n\twhile (s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tstart = i;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t\tarr[j++] = ft_substr(s, start, i - start);\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[j] = NULL;\n}\n\nchar\t**ft_split(char const *s, char c)\n{\n\tchar\t**arr;\n\tsize_t\twords;\n\n\tif (!s)\n\t\treturn (NULL);\n\twords = count_words(s, c);\n\tarr = (char **)malloc(sizeof(char *) * (words + 1));\n\tif (!arr)\n\t\treturn (NULL);\n\tpopulate_split(arr, s, c);\n\treturn (arr);\n}\n\nchar\t*ft_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\tsize_t\ti;\n\tsize_t\tj;\n    size_t  len1; // Added\n    size_t  len2; // Added\n\n\tif (!s2) // If s2 is NULL, cannot join anything meaningful\n\t\treturn (NULL);\n\n    // Handle s1 being NULL by treating its length as 0\n    len1 = (s1 == NULL) ? 0 : ft_strlen(s1);\n    len2 = ft_strlen(s2);\n\n\tnew_str = (char *)malloc(len1 + len2 + 1); // Use calculated lengths\n\tif (!new_str)\n\t\treturn (NULL);\n\n\ti = 0;\n\tif (s1) // Only copy s1 if it's not NULL\n\t{\n\t\twhile (s1[i])\n\t\t{\n\t\t\tnew_str[i] = s1[i];\n\t\t\ti++;\n\t\t}\n\t}\n\tj = 0;\n\twhile (s2[j])\n\t{\n\t\tnew_str[i + j] = s2[j];\n\t\tj++;\n\t}\n\tnew_str[i + j] = '\\0';\n\treturn (new_str);\n}\nint\tft_strcmp(const char *s1, const char *s2)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n\nint\tft_strncmp(const char *s1, const char *s2, size_t n)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (n == 0)\n\t\treturn (0);\n\twhile (i < n - 1 && s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n",
  "tools/strings/strings2.c": "#include \"cub3d.h\"\n\nchar\t*ft_strdup(char *value)\n{\n\tchar\t*result;\n\tint\t\ti;\n\tint\t\tlen;\n\n\tif (!value)\n\t\treturn (NULL);\n\tlen = ft_strlen(value);\n\tresult = malloc(sizeof(char) * (len + 1));\n\tif (!result)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (value[i] != '\\0')\n\t{\n\t\tresult[i] = value[i];\n\t\ti++;\n\t}\n\tresult[i] = '\\0';\n\treturn (result);\n}\n\nsize_t\tft_strlen(const char *s)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (!s)\n\t\treturn (0);\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\n\nchar\t*ft_substr(char const *s, unsigned int start, size_t len)\n{\n\tsize_t\ti;\n\tchar\t*r;\n\tsize_t\ts_len;\n\n\tif (!s)\n\t\treturn (NULL);\n\ts_len = ft_strlen(s);\n\tif (s_len < start)\n\t\treturn (ft_strdup(\"\"));\n\tif (len > s_len - start)\n\t\tlen = s_len - start;\n\tr = malloc(len + 1);\n\tif (!r)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < len)\n\t{\n\t\tr[i] = s[start + i];\n\t\ti++;\n\t}\n\tr[i] = '\\0';\n\treturn (r);\n}\nint\tft_isdigit(int c)\n{\n\treturn (c >= '0' && c <= '9');\n}",
  "tools/strings/strings3.c": "#include \"cub3d.h\"\n\nstatic int\tcount_digits(int n)\n{\n\tint\tcount;\n\n\tcount = 1;\n\twhile (n / 10)\n\t{\n\t\tn /= 10;\n\t\tcount++;\n\t}\n\treturn (count);\n}\n\nchar\t*ft_itoa(int n)\n{\n\tchar\t\t*str;\n\tlong\t\tnum;\n\tint\t\t\tlen;\n\tint\t\t\tis_negative;\n\n\tnum = n;\n\tis_negative = (num < 0);\n\tif (is_negative)\n\t\tnum = -num;\n\tlen = count_digits(num) + is_negative;\n\tstr = malloc(sizeof(char) * (len + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tstr[len] = '\\0';\n\twhile (len-- > 0)\n\t{\n\t\tstr[len] = '0' + (num % 10);\n\t\tnum /= 10;\n\t\tif (len == 0 && is_negative)\n\t\t\tstr[0] = '-';\n\t}\n\treturn (str);\n}\n\n#include <limits.h>\n\nint ft_atoi(const char *str)\n{\n    long result = 0;\n    int  sign = 1;\n    int  i = 0;\n\n    // Skip whitespace\n    while (str[i] == ' ' || (str[i] >= '\\t' && str[i] <= '\\r'))\n        i++;\n\n    // Check sign\n    if (str[i] == '-' || str[i] == '+')\n    {\n        if (str[i] == '-')\n            sign = -1;\n        i++;\n    }\n\n    // Parse digits\n    while (str[i] >= '0' && str[i] <= '9')\n    {\n        int digit = str[i] - '0';\n\n        // Check overflow BEFORE multiplying\n        if (result > (LONG_MAX - digit) / 10)\n        {\n            if (sign == 1)\n                return (INT_MAX);   // positive overflow\n            else\n                return (INT_MIN);   // negative overflow\n        }\n\n        result = result * 10 + digit;\n        i++;\n    }\n\n    result *= sign;\n\n    // Final range check (should not be needed, but safe)\n    if (result > INT_MAX)\n        return INT_MAX;\n    if (result < INT_MIN)\n        return INT_MIN;\n\n    return (int)result;\n}\n\n\n\nchar\t*ft_strchr(const char *s, int c)\n{\n\twhile (*s)\n\t{\n\t\tif (*s == (char)c)\n\t\t\treturn ((char *)s);\n\t\ts++;\n\t}\n\tif ((char)c == '\\0')\n\t\treturn ((char *)s);\n\treturn (NULL);\n}\n\nvoid free_split(char **arr)\n{\n    int i = 0;\n    if (!arr) return;\n    while (arr[i])\n    {\n        free(arr[i]);\n        i++;\n    }\n    free(arr);\n}\nchar *ft_strtrim_newline(char *s)\n{\n    size_t len;\n    char *trimmed_s;\n\n    if (!s)\n        return NULL;\n\n    len = ft_strlen(s);\n    while (len > 0 && (s[len - 1] == '\\n' || s[len - 1] == ' ' || s[len - 1] == '\\r' || s[len - 1] == '\\t'))\n    {\n        len--;\n    }\n\n    trimmed_s = ft_substr(s, 0, len);\n    return trimmed_s;\n}"
}