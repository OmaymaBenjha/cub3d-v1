{
  "cub3d.h": "#ifndef CUB3D_H\n#define CUB3D_H\n# ifndef BUFFER_SIZE\n#  define BUFFER_SIZE 42\n#endif\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <limits.h> \n#include <string.h>\n\ntypedef struct s_gc_node\n{\n\tvoid\t\t\t\t*pt;\n\tstruct s_gc_node\t*next;\n}\tt_gc_node;\ntypedef enum e_co_type\n{\n    NO,\n    SO,\n    WE,\n    EA,\n    F,\n    C\n} t_co_type;\n\ntypedef struct s_color\n{\n    int r;\n    int g;\n    int b;\n    int rgb;\n}   t_color;\ntypedef struct s_textures\n{\n    void    *img_ptr;\n    char    *addr;\n    int     bpp;\n    int     line_len;\n    int     endian;\n    int     width;\n    int     height;\n    char    *path;\n}   t_textures;\ntypedef struct s_config\n{\n    t_textures  no_tex;\n    t_textures  so_tex;\n    t_textures  we_tex;\n    t_textures  ea_tex;\n    t_color     f_color;\n    t_color     c_color;\n    int         all_done;\n    t_co_type   type;\n} t_config;\ntypedef struct s_game\n{\n    void        *mlx_ptr;\n    void        *win_ptr;\n    t_textures  img_buffer;\n    t_config    config;\n    char        **map;\n    int         map_width;\n    int         map_height;\n    int         map_started;\n} t_game;\n\n\nint     ft_strcmp(const char *s1, const char *s2);\nvoid    free_split(char **arr);\nchar\t*get_next_line(int fd);\nchar\t**ft_split(char const *s, char c);\nchar\t*ft_strjoin(char const *s1, char const *s2);\nint     ft_strcmp(const char *s1, const char *s2);\nint     ft_strncmp(const char *s1, const char *s2, size_t n);\nchar\t*ft_strdup(char *value);\nsize_t  ft_strlen(const char *s);\nchar\t*ft_substr(char const *s, unsigned int start, size_t len);\nint     ft_atoi(const char *str);\nchar\t*ft_strchr(const char *s, int c);\n\n// map checking and parsing --------------------------------\nint     pre_check(int ac, char **av);\nint     main_trigger(char *map, t_game *game);\nint     process_tex(char **tex_tokens, t_config *config, int *current_line_done);\nint process_fc(char **fc_tokens, t_config *config, int *current_line_done);\n\n#endif",
  "main.c": "#include \"cub3d.h\"\n\n\nint main(int ac, char **av)\n{\n    t_game  game;\n\n    memset(&game, 0, sizeof(t_game));\n    if (!pre_check(ac, av))\n        return (0);\n    if (!main_trigger(av[1], &game))\n        return (0);\n    \n}",
  "Makefile": "NAME = cub3d\nCC = gcc\nCFLAGS = -Wall -Wextra -Werror  \nRM = rm -f\n\nSRCS =\tmain.c \\\n\t\tlogic_parsing/check_args.c \\\n\t\tlogic_parsing/fetch_map.c \\\n\t\tlogic_parsing/map_config_fc.c \\\n\t\tlogic_parsing/map_config_tex.c \\\n\t\ttools/strings/strings1.c \\\n\t\ttools/strings/strings2.c \\\n\t\ttools/strings/strings3.c \\\n\t\ttools/get_next_line.c\n\n\n\n\nOBJS = $(SRCS:.c=.o)\n\nall: $(NAME)\n\n$(NAME): $(OBJS)\n\t$(CC) $(CFLAGS) -o $(NAME) $(OBJS) \n\n%.o: %.c cub3d.h\n\t$(CC) $(CFLAGS) -I. -c $< -o $@\n\nclean:\n\t$(RM) $(OBJS)\n\nfclean: clean\n\t$(RM) $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re\n",
  "logic_parsing/check_args.c": "#include \"cub3d.h\"\n\nstatic int is_valid_file(char *fname)\n{\n    char *ext;\n\n    ext = ft_strchr(fname, '.');\n    if (!ext || ft_strchr(fname, ' '))\n        return (0);\n    if (ft_strcmp(ext, \".cub\") != 0)\n        return (0);\n    return (1);\n}\n\nint pre_check(int ac, char **av)\n{\n    if (ac != 2)\n    {\n        printf(\"ERROR\\nFew arguments!\\nUsage: ./cub3d [./path_to_the_map_file]\\n]\");\n        return (0);\n    }\n    if (!is_valid_file(av[1]))\n    {\n        printf(\"ERROR\\nInvalid map file!\\n\");\n        return (0);\n    }\n    return (1);\n}\n",
  "logic_parsing/fetch_map.c": "#include \"cub3d.h\"\n\nstatic int process_config_line(char **s_line, t_config *config)\n{\n    int current_line_done;\n\n    current_line_done = 0;\n    if (ft_strcmp(s_line[0], \"NO\") == 0 || ft_strcmp(s_line[0], \"SO\") == 0 ||\n        ft_strcmp(s_line[0], \"EA\") == 0 || ft_strcmp(s_line[0], \"WE\") == 0)\n    {\n        if (!process_tex(s_line, config, &current_line_done))\n            return (0);\n    }\n    else if (ft_strcmp(s_line[0], \"F\") == 0 || ft_strcmp(s_line[0], \"C\") == 0)\n    {\n        if (!process_fc(s_line, config, &current_line_done))\n            return (0);\n    }\n    else\n    {\n        printf(\"Error\\nUnknown identifier in config section: %s\\n\", s_line[0]);\n        return (0);\n    }\n    if (current_line_done)\n    {\n        config->all_done++;\n    }\n    return (1);\n}\nstatic int is_empty(char *line)\n{\n    if (!line) return (1);\n    while (*line)\n    {\n        if (*line != ' ' && *line != '\\t' && *line != '\\n')\n            return (0);\n        line++;\n    }\n    return (1);\n}\n\nstatic int parse_line(char *line, t_game *game)\n{\n    char    **tokens;\n\n    if (is_empty(line) && !game->map_started)\n        return (1);\n    else if (!is_empty(line) && game->map_started)\n        return (printf(\"Error\\nfound an empty line inside map data.\\n\"), 0);\n    tokens = ft_split(line, ' ');\n    if (!tokens)\n        return (printf(\"Error\\nft_split failed\\n\"), 0);\n    if (game->config.all_done < 6)\n    {\n        if (!process_config_line(tokens, &game->config))\n            return (free_split(tokens), 0);\n    }\n    else\n    {\n        printf(\"map\\n\");\n            return (free_split(tokens), 0);\n    }\n    free_split(tokens);\n    return (1);\n}\n\nint main_trigger(char *map, t_game *game)\n{\n    int     fd;\n    char    *line;\n\n    game->config.all_done = 0;\n    game->map_started = 0;\n    fd = open(map, O_RDONLY);\n    if (fd < 0)\n        (perror(\"open\"), exit(EXIT_FAILURE));\n    line = get_next_line(fd);\n    if (line == NULL)\n        printf(\"ikhan\\n\");\n    while (line != NULL)\n    {\n        printf(\"line: %s\", line);\n        if (parse_line(line, game) == 0)\n            return (close(fd), 0);\n        free(line);\n        line = get_next_line(fd);\n    }\n    close(fd);\n    if (game->config.all_done < 6)\n        return (printf(\"Error\\nMissing one or more config id.\\n\"), 0);\n    if (!game->map_started)\n        return (printf(\"Error\\nmap data wasn't found in file\\n\"));\n    if (game->config.all_done == 0 && !game->map_started)\n        return (printf(\"map file cannot be empty!\"), 0);\n    return (1);\n}\n",
  "logic_parsing/map_config_fc.c": "#include \"cub3d.h\"\nstatic t_color get_representation(char **tokens, int *line)\n{\n    t_color c;\n    int     r;\n    int     g;\n    int     b;\n\n    memset(&c, 0, sizeof(t_color));\n    r = atoi(tokens[0]);\n    g = atoi(tokens[1]);\n    b = atoi(tokens[2]);\n    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 )\n    {\n        *line = 0;\n        return (printf(\"Error\\nrgb is out of range.\\n\"), c);\n    }\n    c.r = r;\n    c.g = g;\n    c.b = b;\n    c.rgb = (c.r << 16) | (c.g << 8) | c.b;\n    return (c);\n}\nstatic void    fill_color(t_config *config, t_co_type type, char **rgb_tokens, int *line)\n{\n    t_color tmp_color;\n\n    tmp_color = get_representation(rgb_tokens, line);\n    if (type == F)\n        config->f_color = tmp_color;\n    else    \n        config->c_color = tmp_color;\n    if (line == 0)\n        return;\n}\nint process_fc(char **fc_tokens, t_config *config, int *current_line_done)\n{\n    char    **rgb;\n\n    *current_line_done = 0;\n    if (!fc_tokens[1])\n        return (printf(\"Error\\n missing rgb representation for %s...\\n\", fc_tokens[0]), 0);\n    rgb = ft_split(fc_tokens[1], ',');\n    if (!rgb)\n        return (printf(\"Error\\nft_split failed!\\n\"));\n    if (!rgb[0] || !rgb[1] || !rgb[2] || rgb[3] != NULL)\n        return (printf(\"Error\\ninvalid rgb representation\\n\"));\n    if (ft_strcmp(fc_tokens[0], \"F\") == 0)\n        fill_color(config, F, rgb, current_line_done);\n    else if (ft_strcmp(fc_tokens[0], \"C\") == 0)\n        fill_color(config, C, rgb, current_line_done);\n    if (!(*current_line_done))\n        return (0);\n    return (1);\n}",
  "logic_parsing/map_config_tex.c": "#include \"cub3d.h\"\n\nstatic t_textures get_texture(char **tex_tokens, int *done)\n{\n    t_textures  t;\n    int         fd;\n\n    memset(&t, 0, sizeof(t_textures));\n    if (!tex_tokens || !tex_tokens[0] || !tex_tokens[1] || tex_tokens[2] != NULL)\n    {\n        printf(\"Error\\nInvalid texture line format. Expected 'IDENTIFIER PATH'.\\n\");\n        *done = 0;\n        return (t);\n    }\n    t.path = ft_strdup(tex_tokens[1]);\n    if (!t.path)\n    {\n        perror(\"Error\\nMalloc failed for texture path\");\n        *done = 0;\n        return (t);\n    }\n    fd = open(t.path, O_RDONLY);\n    if (fd < 0)\n    {\n        perror(\"Error\\nCannot open texture path\");\n        *done = 0;\n        return (t);\n    }\n    close(fd);\n    *done = 1;\n    return (t);\n}\nstatic void    fill_config(t_config *config, t_co_type type, char **tex_tokens, int *current_line_done)\n{\n    t_textures temp_tex;\n\n    temp_tex = get_texture(tex_tokens, current_line_done);\n    if (*current_line_done == 0)\n        return;\n    if (type == NO)\n    {\n        if (config->no_tex.path != NULL) { printf(\"Error\\nDuplicate NO texture definition.\\n\"); *current_line_done = 0; return; }\n        config->no_tex = temp_tex;\n    }\n    else if (type == SO)\n    {\n        if (config->so_tex.path != NULL) { printf(\"Error\\nDuplicate SO texture definition.\\n\"); *current_line_done = 0; return; }\n        config->so_tex = temp_tex;\n    }\n    else if (type == EA)\n    {\n        if (config->ea_tex.path != NULL) { printf(\"Error\\nDuplicate EA texture definition.\\n\"); *current_line_done = 0; return; }\n        config->ea_tex = temp_tex;\n    }\n    else if (type == WE)\n    {\n        if (config->we_tex.path != NULL) { printf(\"Error\\nDuplicate WE texture definition.\\n\"); *current_line_done = 0; return; }\n        config->we_tex = temp_tex;\n    }\n}\n\nint process_tex(char **tex_tokens, t_config *config, int *current_line_done)\n{\n    *current_line_done = 0;\n    if (ft_strcmp(tex_tokens[0], \"NO\") == 0)\n        fill_config(config, NO, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"SO\") == 0)\n        fill_config(config, SO, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"EA\") == 0)\n        fill_config(config, EA, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"WE\") == 0)\n        fill_config(config, WE, tex_tokens, current_line_done);\n    else\n    {\n        printf(\"Error\\nInvalid texture identifier: %s\\n\", tex_tokens[0]);\n        return (0);\n    }\n    if (!(*current_line_done))\n        return (0);\n    if (tex_tokens[2] != NULL)\n    {\n        printf(\"Error\\nToo many arguments on texture line '%s %s ...'\\n\", tex_tokens[0], tex_tokens[1]);\n        return (0);\n    }\n    return (1);\n}",
  "tools/get_next_line.c": "\n#include \"cub3d.h\"\n\n\nstatic char\t*get_line(char *reserve)\n{\n\tint\t\tstart;\n\tchar\t*line;\n\tint\t\ti;\n\n\tstart = 0;\n\ti = 0;\n\twhile (reserve[i] != '\\n' && reserve[i] != '\\0')\n\t\ti++;\n\tif (reserve[i] == '\\n')\n\t\ti++;\n\tline = ft_substr(reserve, start, i);\n\treturn (line);\n}\n\nstatic char\t*update_reserve(char *reserve)\n{\n\tchar\t*new_res;\n\tint\t\ti;\n\n\ti = 0;\n\twhile (reserve[i] != '\\n' && reserve[i] != '\\0')\n\t\ti++;\n\tnew_res = ft_substr(reserve, i + 1, ft_strlen(reserve) - i - 1);\n\tfree(reserve);\n\treserve = NULL;\n\treturn (new_res);\n}\n\nstatic char\t*helper_func(char *buffer, char *reserve, int fd)\n{\n\tint\tbytes_read;\n\n\tbytes_read = 1;\n\twhile (bytes_read)\n\t{\n\t\tbytes_read = read(fd, buffer, BUFFER_SIZE);\n\t\tif (bytes_read == -1)\n\t\t\treturn (free(buffer), free(reserve), reserve = NULL, NULL);\n\t\tbuffer[bytes_read] = '\\0';\n\t\treserve = ft_strjoin(reserve, buffer);\n\t\tif (!reserve)\n\t\t\treturn (NULL);\n\t\tif (ft_strchr(reserve, '\\n'))\n\t\t\tbreak ;\n\t}\n\tfree(buffer);\n\treturn (reserve);\n}\n\nchar\t*get_next_line(int fd)\n{\n\tstatic char\t*reserve = NULL;\n\tchar\t\t*buffer;\n\tchar\t\t*line;\n\n\tif (fd < 0 || BUFFER_SIZE <= 0 || BUFFER_SIZE > INT_MAX)\n\t\treturn (free(reserve), reserve = NULL, NULL);\n\tbuffer = malloc((size_t) BUFFER_SIZE + 1);\n\tif (!buffer)\n\t\treturn (NULL);\n\treserve = helper_func(buffer, reserve, fd);\n\tif (!reserve || *reserve == '\\0')\n\t\treturn (free(reserve), reserve = NULL, NULL);\n\tline = get_line(reserve);\n\treserve = update_reserve(reserve);\n\treturn (line);\n}\n",
  "tools/garbage_collector/gc_mall.c": "#include \"cub3d.h\"\n\nstatic t_gc_node\t**get_gc_head_instance(void)\n{\n\tstatic t_gc_node\t*head;\n\n\treturn (&head);\n}\n\nvoid\tgc_add_pt(void *pt)\n{\n\tt_gc_node\t*new_node;\n\tt_gc_node\t**head;\n\n\tif (!pt)\n\t\treturn ;\n\thead = get_gc_head_instance();\n\tnew_node = (t_gc_node *)malloc(sizeof(t_gc_node));\n\tif (!new_node)\n\t{\n\t\tperror(\"malloc failed in garbage collector\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tnew_node->pt = pt;\n\tnew_node->next = *head;\n\t*head = new_node;\n}\n\nchar\t*gc_strdup(char *str)\n{\n\tchar\t*new_str;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = ft_strdup(str);\n\tif (!new_str)\n\t{\n\t\tperror(\"strdup failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nchar\t*gc_substr(char const *s, unsigned int start, size_t len)\n{\n\tchar\t*new_str;\n\n\tif (!s)\n\t\treturn (NULL);\n\tnew_str = ft_substr(s, start, len);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\tgc_freed(void)\n{\n\tt_gc_node\t*current;\n\tt_gc_node\t*tmp;\n\tt_gc_node\t**head;\n\n\thead = get_gc_head_instance();\n\tcurrent = *head;\n\twhile (current != NULL)\n\t{\n\t\ttmp = current;\n\t\tcurrent = current->next;\n\t\tfree(tmp->pt);\n\t\tfree(tmp);\n\t}\n\t*head = NULL;\n}\n",
  "tools/garbage_collector/gc_mall2.c": "#include \"cub3d.h\"\n\nchar\t*gc_itoa(int n)\n{\n\tchar\t*new_str;\n\n\tnew_str = ft_itoa(n);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\t*gc_mall(size_t size)\n{\n\tvoid\t*pt;\n\n\tpt = malloc(size);\n\tif (!pt)\n\t{\n\t\tperror(\"malloc failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(pt);\n\treturn (pt);\n}\n\nchar\t*gc_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = ft_strjoin(s1, s2);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n",
  "tools/strings/strings1.c": "#include \"cub3d.h\"\n\nstatic size_t\tcount_words(char const *s, char c)\n{\n\tsize_t\tcount;\n\tsize_t\ti;\n\n\tcount = 0;\n\ti = 0;\n\twhile (s && s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tcount++;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\treturn (count);\n}\n\nstatic void\tpopulate_split(char **arr, char const *s, char c)\n{\n\tsize_t\ti;\n\tsize_t\tj;\n\tsize_t\tstart;\n\n\ti = 0;\n\tj = 0;\n\twhile (s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tstart = i;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t\tarr[j++] = ft_substr(s, start, i - start);\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[j] = NULL;\n}\n\nchar\t**ft_split(char const *s, char c)\n{\n\tchar\t**arr;\n\tsize_t\twords;\n\n\tif (!s)\n\t\treturn (NULL);\n\twords = count_words(s, c);\n\tarr = (char **)malloc(sizeof(char *) * (words + 1));\n\tif (!arr)\n\t\treturn (NULL);\n\tpopulate_split(arr, s, c);\n\treturn (arr);\n}\n\nchar\t*ft_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\tsize_t\ti;\n\tsize_t\tj;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = (char *)malloc(ft_strlen(s1) + ft_strlen(s2) + 1);\n\tif (!new_str)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (s1[i])\n\t{\n\t\tnew_str[i] = s1[i];\n\t\ti++;\n\t}\n\tj = 0;\n\twhile (s2[j])\n\t{\n\t\tnew_str[i + j] = s2[j];\n\t\tj++;\n\t}\n\tnew_str[i + j] = '\\0';\n\treturn (new_str);\n}\n\nint\tft_strcmp(const char *s1, const char *s2)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n\nint\tft_strncmp(const char *s1, const char *s2, size_t n)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (n == 0)\n\t\treturn (0);\n\twhile (i < n - 1 && s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n",
  "tools/strings/strings2.c": "#include \"cub3d.h\"\n\nchar\t*ft_strdup(char *value)\n{\n\tchar\t*result;\n\tint\t\ti;\n\tint\t\tlen;\n\n\tif (!value)\n\t\treturn (NULL);\n\tlen = ft_strlen(value);\n\tresult = malloc(sizeof(char) * (len + 1));\n\tif (!result)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (value[i] != '\\0')\n\t{\n\t\tresult[i] = value[i];\n\t\ti++;\n\t}\n\tresult[i] = '\\0';\n\treturn (result);\n}\n\nsize_t\tft_strlen(const char *s)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (!s)\n\t\treturn (0);\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\n\nchar\t*ft_substr(char const *s, unsigned int start, size_t len)\n{\n\tsize_t\ti;\n\tchar\t*r;\n\tsize_t\ts_len;\n\n\tif (!s)\n\t\treturn (NULL);\n\ts_len = ft_strlen(s);\n\tif (s_len < start)\n\t\treturn (ft_strdup(\"\"));\n\tif (len > s_len - start)\n\t\tlen = s_len - start;\n\tr = malloc(len + 1);\n\tif (!r)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < len)\n\t{\n\t\tr[i] = s[start + i];\n\t\ti++;\n\t}\n\tr[i] = '\\0';\n\treturn (r);\n}\n",
  "tools/strings/strings3.c": "#include \"cub3d.h\"\n\nstatic int\tcount_digits(int n)\n{\n\tint\tcount;\n\n\tcount = 1;\n\twhile (n / 10)\n\t{\n\t\tn /= 10;\n\t\tcount++;\n\t}\n\treturn (count);\n}\n\nchar\t*ft_itoa(int n)\n{\n\tchar\t\t*str;\n\tlong\t\tnum;\n\tint\t\t\tlen;\n\tint\t\t\tis_negative;\n\n\tnum = n;\n\tis_negative = (num < 0);\n\tif (is_negative)\n\t\tnum = -num;\n\tlen = count_digits(num) + is_negative;\n\tstr = malloc(sizeof(char) * (len + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tstr[len] = '\\0';\n\twhile (len-- > 0)\n\t{\n\t\tstr[len] = '0' + (num % 10);\n\t\tnum /= 10;\n\t\tif (len == 0 && is_negative)\n\t\t\tstr[0] = '-';\n\t}\n\treturn (str);\n}\n\nint\tft_atoi(const char *str)\n{\n\tint\t\ti;\n\tint\t\tsign;\n\tlong\tresult;\n\n\ti = 0;\n\tsign = 1;\n\tresult = 0;\n\twhile (str[i] == ' ' || (str[i] >= '\\t' && str[i] <= '\\r'))\n\t\ti++;\n\tif (str[i] == '-' || str[i] == '+')\n\t{\n\t\tif (str[i] == '-')\n\t\t\tsign = -1;\n\t\ti++;\n\t}\n\twhile (str[i] >= '0' && str[i] <= '9')\n\t{\n\t\tresult = result * 10 + (str[i] - '0');\n\t\ti++;\n\t}\n\treturn ((int)(result * sign));\n}\n\nchar\t*ft_strchr(const char *s, int c)\n{\n\twhile (*s)\n\t{\n\t\tif (*s == (char)c)\n\t\t\treturn ((char *)s);\n\t\ts++;\n\t}\n\tif ((char)c == '\\0')\n\t\treturn ((char *)s);\n\treturn (NULL);\n}\n\nvoid free_split(char **arr)\n{\n    int i = 0;\n    if (!arr) return;\n    while (arr[i])\n    {\n        free(arr[i]);\n        i++;\n    }\n    free(arr);\n}\n"
}