{
  "cub3d.h": "#ifndef CUB3D_H\n#define CUB3D_H\n# ifndef BUFFER_SIZE\n#  define BUFFER_SIZE 42\n#endif\n#include <unistd.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <limits.h> \n#include <string.h>\n#include <math.h>     // <--- You will likely need math.h too\n#include \"mlx.h\" \n\ntypedef struct s_gc_node\n{\n\tvoid\t\t\t\t*pt;\n\tstruct s_gc_node\t*next;\n}\tt_gc_node;\n\ntypedef enum e_co_type\n{\n    NO,\n    SO,\n    WE,\n    EA,\n    F,\n    C\n} t_co_type;\n\ntypedef struct s_color\n{\n    int r;\n    int g;\n    int b;\n    int rgb;\n}   t_color;\ntypedef struct s_textures\n{\n    void    *img_ptr;\n    char    *addr;\n    int     bpp;\n    int     line_len;\n    int     endian;\n    int     width;\n    int     height;\n    char    *path;\n}   t_textures;\ntypedef struct s_config\n{\n    t_textures  no_tex;\n    t_textures  so_tex;\n    t_textures  we_tex;\n    t_textures  ea_tex;\n    t_color     f_color;\n    t_color     c_color;\n    int         f_has_been_set;\n    int         c_has_been_set;\n    int         all_done;\n    t_co_type   type;\n} t_config;\n\ntypedef struct s_player\n{\n    double  posX;\n    double  posY;\n    double  dirX;\n    double  dirY;\n    double  planeX;\n    double  planeY;\n}   t_player;\n\ntypedef struct s_game\n{\n    void        *mlx_ptr;\n    void        *win_ptr;\n    t_textures  img_buffer;\n    t_config    config;\n    char        **map;\n    size_t      map_width;\n    size_t      map_height;\n    int         map_started;\n    int         map_ended;\n    int         player_count;\n    t_player    player;\n} t_game;\n\n\nint         ft_strcmp(const char *s1, const char *s2);\nvoid        free_split(char **arr);\nchar        *get_next_line(int fd);\nchar        **ft_split(char const *s, char c);\nchar        *ft_strjoin(char const *s1, char const *s2);\nint         ft_strcmp(const char *s1, const char *s2);\nint         ft_strncmp(const char *s1, const char *s2, size_t n);\nchar        *ft_strdup(char *value);\nsize_t      ft_strlen(const char *s);\nchar        *ft_substr(char const *s, unsigned int start, size_t len);\nint         ft_atoi(const char *str);\nchar        *ft_strchr(const char *s, int c);\nchar        *ft_strtrim_newline(char *s);\nint         ft_isdigit(int c);\n// garbage collector----------------------------------------\nchar        *gc_strdup(char *str);\nvoid        gc_add_pt(void *pt);\nchar        *gc_substr(char const *s, unsigned int start, size_t len);\nvoid        gc_freed(void);\nchar        **gc_split(char const *s, char c);\nchar        *gc_strjoin(char const *s1, char const *s2);\nvoid       *gc_mall(size_t size);\n\n// map checking and parsing --------------------------------\nint         pre_check(int ac, char **av);\nint         main_trigger(char *map, t_game *game);\nint         process_tex(char **tex_tokens, t_config *config, int *current_line_done);\nint         process_fc(char **fc_tokens, t_config *config, int *current_line_done);\nint         is_player_char(char c);\nint         process_map(char *line, t_game *game);\nint         check_map_closed(t_game *game);\nint         is_map_char(char c);\nvoid        get_player_cord(t_game *game);\nvoid        make_map_rectangular(t_game *game);\n\n// game core ---------------------------------------------\n\nvoid    init_game(t_game *game);\n\n#endif",
  "main.c": "#include \"cub3d.h\"\n\n\nint main(int ac, char **av)\n{\n    t_game  game;\n\n    memset(&game, 0, sizeof(t_game));\n    if (!pre_check(ac, av))\n        return (0);\n    if (main_trigger(av[1], &game))\n        return (1);\n    get_player_cord(&game);\n    make_map_rectangular(&game);\n    init_game(&game);\n    gc_freed();\n    return (0);\n}",
  "Makefile": "NAME = cub3d\nCC = gcc\nCFLAGS = -Wall -Wextra -Werror -g -fsanitize=address\nRM = rm -f\n\n# --- 1. MLX CONFIGURATION ---\nMLX_PATH = ./minilibx-linux\nMLX_NAME = mlx\nMLX_LIB  = $(MLX_PATH)/libmlx.a\n\n# Includes: Look for headers in current dir AND mlx dir\nINCLUDES = -I. -I$(MLX_PATH)\n\n# Linker: Look for libs in mlx dir, link mlx, link linux system libs\nMLX_FLAGS = -L$(MLX_PATH) -l$(MLX_NAME) -lXext -lX11 -lm -lz\n# ----------------------------\n\nSRCS =\tmain.c \\\n\t\tcore/graphics.c \\\n\t\tlogic_parsing/check_args.c \\\n\t\tlogic_parsing/fetch_map.c \\\n\t\tlogic_parsing/map_config_fc.c \\\n\t\tlogic_parsing/map_config_tex.c \\\n\t\tlogic_parsing/map_data.c \\\n\t\tlogic_parsing/map_data_helper.c \\\n\t\tlogic_parsing/player_cord.c \\\n\t\tlogic_parsing/final_map.c \\\n\t\ttools/strings/strings1.c \\\n\t\ttools/strings/strings2.c \\\n\t\ttools/strings/strings3.c \\\n\t\ttools/get_next_line.c \\\n\t\ttools/garbage_collector/gc_mall.c \\\n\t\ttools/garbage_collector/gc_mall2.c\n\nOBJS = $(SRCS:.c=.o)\n\n# 2. Add MLX_LIB as a requirement\nall: $(MLX_LIB) $(NAME)\n\n# 3. Rule to compile the MLX library if it's missing\n$(MLX_LIB):\n\t@make -C $(MLX_PATH)\n\n# 4. Link everything together (MLX_FLAGS at the end)\n$(NAME): $(OBJS)\n\t$(CC) $(CFLAGS) $(OBJS) $(MLX_FLAGS) -o $(NAME) \n\n# 5. Compile .c to .o with the new includes\n%.o: %.c cub3d.h\n\t$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@\n\nclean:\n\t$(RM) $(OBJS)\n\t@make clean -C $(MLX_PATH)\n\nfclean: clean\n\t$(RM) $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re",
  "core/graphics.c": "#include \"cub3d.h\"\n\n#define TILE_SIZE 30 // Size of each block in pixels\n\nvoid    my_mlx_pixel_put(t_textures *data, int x, int y, int color)\n{\n    char    *dst;\n\n    if (x < 0 || x >= 800 || y < 0 || y >= 800)\n        return;\n    dst = data->addr + (y * data->line_len + x * (data->bpp / 8));\n    *(unsigned int*)dst = color;\n}\n\n// Helper to draw a solid square at a specific map coordinate\nvoid    draw_tile(t_game *game, int map_x, int map_y, int color)\n{\n    size_t x;\n    size_t y;\n\n    // Calculate where this tile starts on the screen\n    int screen_x = map_x * TILE_SIZE;\n    int screen_y = map_y * TILE_SIZE;\n\n    y = 0;\n    while (y < TILE_SIZE - 1) // -1 to leave a tiny border (grid effect)\n    {\n        x = 0;\n        while (x < TILE_SIZE - 1)\n        {\n            my_mlx_pixel_put(&game->img_buffer, screen_x + x, screen_y + y, color);\n            x++;\n        }\n        y++;\n    }\n}\n\nvoid    drawing(t_game *game)\n{\n    size_t y;\n    size_t x;\n    int color;\n\n    y = 0;\n    // Loop through the MAP array, not pixels\n    while (y < game->map_height) \n    {\n        x = 0;\n        // Careful: Use the map width or strlen to avoid segfaults\n        while (game->map[y][x]) \n        {\n            // 1. Determine Color\n            if (x == game->player.posX && y == game->player.posY)\n                color = 0x00FF00; // GREEN (Player)\n            else if (game->map[y][x] == '1')\n                color = 0x8B4513; // BROWN (Wall)\n            else if (game->map[y][x] == '0' || game->map[y][x] == ' ')\n                color = 0x808080; // GREY (Space/Empty)\n            else\n                color = 0x000000; // Black (Unknown)\n\n            // 2. Draw the square for this map block\n            draw_tile(game, x, y, color);\n            x++;\n        }\n        y++;\n    }\n}\n\nvoid    init_game(t_game *game)\n{\n    // 1. Init MLX\n    game->mlx_ptr = mlx_init();\n    if (!game->mlx_ptr)\n        (printf(\"MLX init failed\\n\"), exit(1));\n    game->win_ptr = mlx_new_window(game->mlx_ptr, 800, 800, \"cub3d\");\n    if (!game->win_ptr)\n        (printf(\"Window creation failed\\n\"), exit(1));\n\n    // 2. Create Image Buffer\n    game->img_buffer.img_ptr = mlx_new_image(game->mlx_ptr, 800, 800);\n    game->img_buffer.addr = mlx_get_data_addr(game->img_buffer.img_ptr, \n        &game->img_buffer.bpp, &game->img_buffer.line_len, &game->img_buffer.endian);\n\n    // 3. Draw the Map\n    drawing(game);\n\n    // 4. Push to Window\n    mlx_put_image_to_window(game->mlx_ptr, game->win_ptr, game->img_buffer.img_ptr, 0, 0);\n\n    mlx_loop(game->mlx_ptr);\n}",
  "logic_parsing/check_args.c": "#include \"cub3d.h\"\n\nstatic int is_valid_file(char *fname)\n{\n    char *ext;\n\n    ext = ft_strchr(fname, '.');\n    if (!ext || ft_strchr(fname, ' '))\n        return (0);\n    if (ft_strcmp(ext, \".cub\") != 0)\n        return (0);\n    return (1);\n}\n\nint pre_check(int ac, char **av)\n{\n    if (ac != 2)\n    {\n        printf(\"ERROR\\nFew arguments!\\nUsage: ./cub3d [./path_to_the_map_file]\\n]\");\n        return (0);\n    }\n    if (!is_valid_file(av[1]))\n    {\n        printf(\"ERROR\\nInvalid map file!\\n\");\n        return (0);\n    }\n    return (1);\n}\n",
  "logic_parsing/fetch_map.c": "#include \"cub3d.h\"\n\nstatic int process_config_line(char **s_line, t_game *game, char *line)\n{\n    int current_line_done;\n\n    current_line_done = 0;\n    if (ft_strcmp(s_line[0], \"NO\") == 0 || ft_strcmp(s_line[0], \"SO\") == 0 ||\n        ft_strcmp(s_line[0], \"EA\") == 0 || ft_strcmp(s_line[0], \"WE\") == 0)\n    {\n        if (!process_tex(s_line, &game->config, &current_line_done))\n            return (0);\n    }\n    else if (ft_strcmp(s_line[0], \"F\") == 0 || ft_strcmp(s_line[0], \"C\") == 0)\n    {\n        if (!process_fc(s_line, &game->config, &current_line_done))\n            return (0);\n    }\n    else if (game->config.all_done < 6)\n    {\n        char *line_copy;\n        line_copy = gc_strdup(line);\n        if (!line_copy)\n            return (printf(\"Error\\nstrdup failed!\\n\"),0);\n        while (*line_copy)\n        {\n            if (!is_map_char(*line))\n                break;\n            line_copy++;\n        }\n        if (is_map_char(*line))\n            return (printf(\"Error\\nMap data found before or within the map config\\n\"), 0);\n        return(printf(\"Error\\nInvalid texture identifier: %s\\n\", s_line[0]),0);\n    }\n    else\n    {\n       if (!process_map(line, game))\n            return (0);\n       \n    }\n    if (current_line_done)\n    {\n        game->config.all_done++;\n    }\n    return (1);\n}\nstatic int ft_isspace(char c)\n{\n    return (c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == '\\v');\n}\n\nstatic int is_empty(char *line)\n{\n    if (!line)\n        return (1); \n    int i = 0;\n    while (line[i])\n    {\n        if (!ft_isspace(line[i])) \n            return (0);\n        i++;\n    }\n    return (1);\n}\n\nstatic int parse_line(char *line, t_game *game)\n{\n    char    **tokens;\n\n    if (is_empty(line))\n    {\n        if (!game->map_started)\n            return (1);\n        else if (game->map_started && !game->map_ended)\n        {\n            game->map_started = 0;\n            game->map_ended = 1;\n            return 1;\n        }\n    }\n    else if(game->map_ended)\n        return (printf(\"Error\\nfound an empty line inside map data.\\n\"), 0);\n    tokens = gc_split(line, ' ');\n    if (!tokens)\n        return (printf(\"Error\\nft_split failed\\n\"), 0);\n    if (!process_config_line(tokens, game, line))\n            return (0);\n    return (1);\n}\nstatic void initiate_game_struct(t_game *game)\n{\n    game->config.all_done = 0;\n    game->map_started = 0;\n    game->map = NULL;\n    game->map_width = 0;\n    game->map_height = 0;\n    game->map_ended = 0;\n    game->player_count = 0;\n    game->config.c_has_been_set = 0;\n    game->config.f_has_been_set = 0;\n}\n\nstatic int check_game_map_state(t_game *game)\n{\n    if (game->player_count == 0)\n        return(printf(\"Error\\nPlayer starting position is missing in the map.\\nTry: S/N/W/E.\\n\"),0);\n    if (game->config.all_done == 0 && !game->map_started)\n        return (printf(\"Map file cannot be empty!\\n\"), 0);\n    if (game->config.all_done < 6)\n        return (printf(\"Error\\nMissing one or more config id.\\n\"), 0);\n    if (!game->map_started && !game->map_ended)\n        return (printf(\"Error\\nMap data wasn't found in file\\n\"), 0);\n    if (check_map_closed(game))\n        return (0);\n    return (1);\n}\nint main_trigger(char *map, t_game *game)\n{\n    int     fd;\n    char    *line;\n    char    *trimed_line;\n\n    initiate_game_struct(game);\n    fd = open(map, O_RDONLY);\n    if (fd < 0)\n        (perror(\"open\"), exit(EXIT_FAILURE));\n    line = get_next_line(fd);\n    while (line != NULL)\n    {\n        trimed_line = ft_strtrim_newline(line);\n        if (!trimed_line)\n            return (printf(\"ERROR\\nstriming line failed!\\n\"), free(line), close(fd), 0);\n        if (!parse_line(trimed_line, game))\n            return (free(line), close(fd), 0);\n        free(line);\n        line = get_next_line(fd);\n    }\n    close(fd);\n    if (!check_game_map_state(game))\n        return (0);\n    return (1);\n}\n",
  "logic_parsing/final_map.c": "#include \"cub3d.h\"\n\nstatic size_t  get_max_width(t_game *game)\n{\n    size_t  max;\n    size_t  i;\n    size_t  len;\n\n    max = 0;\n    i = 0;\n    while (i < game->map_height)\n    {\n        len = ft_strlen(game->map[i]);\n        if (len > max)\n            max = len;\n        i++;\n    }\n    return (max);\n}\n\nvoid    make_map_rectangular(t_game *game)\n{\n    size_t  i;\n    size_t  j;\n    size_t  len;\n    char    *new_line;\n\n    game->map_width = get_max_width(game);\n    i = 0;\n    while (i < game->map_height)\n    {\n        len = ft_strlen(game->map[i]);\n        if (len < game->map_width)\n        {\n            new_line = gc_mall(sizeof(char) * (game->map_width + 1));\n            if (!new_line)\n                exit(1);\n            j = 0;\n            while (j < len)\n            {\n                new_line[j] = game->map[i][j];\n                j++;\n            }\n            while (j < game->map_width)\n            {\n                new_line[j] = ' ';\n                j++;\n            }\n            new_line[j] = '\\0';\n            game->map[i] = new_line;\n        }\n        i++;\n    }\n}",
  "logic_parsing/map_config_fc.c": "#include \"cub3d.h\"\nstatic t_color get_representation(char **tokens, int *line)\n{\n    t_color c;\n    int     r;\n    int     g;\n    int     b;\n\n    memset(&c, 0, sizeof(t_color));\n    r = ft_atoi(tokens[0]);\n    g = ft_atoi(tokens[1]);\n    b = ft_atoi(tokens[2]);  \n    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 )\n    {\n        *line = 0;\n        return (printf(\"Error\\nrgb is out of range.\\n\"), c);\n    }\n    c.r = r;\n    c.g = g;\n    c.b = b;\n    c.rgb = (c.r << 16) | (c.g << 8) | c.b;\n    return (c);\n}\nstatic void    fill_color(t_config *config, t_co_type type, char **rgb_tokens, int *line)\n{\n    t_color tmp_color;\n\n    tmp_color = get_representation(rgb_tokens, line);\n    if (type == F)\n    {   if (config->f_has_been_set == 1)\n        {\n            printf(\"Error\\nDuplicate F rgb representation!\\n\");\n            line =0;\n        }\n        config->f_color = tmp_color;\n        if (line)\n            config->f_has_been_set++;\n    }\n        \n    else\n    {\n        if (config->c_has_been_set == 1)\n        {\n            printf(\"Error\\nDuplicate C rgb representation!\\n\");\n            line =0;\n        }\n        config->c_color = tmp_color;\n        if (line)\n            config->c_has_been_set++;\n    }    \n    if (line == 0)\n        return;\n}\n\nstatic int not_valid_num(char **rgb)\n{\n    int i;\n    int j;\n\n    i = 0;\n    j = 0;\n    while (rgb[i] != NULL)\n    {\n        while (rgb[i][j])\n        {\n            if (!ft_isdigit(rgb[i][j]) && rgb[i][j] != ' ')\n                return(printf(\"Error\\nInvalid rgb representation: %s\\n\", rgb[i]), 0);\n            j++;\n        }\n        i++;\n        j = 0;\n    }\n    return (1);\n}\nstatic char *join_tokens(char **tokens)\n{\n    char *result;\n    char *tmp;\n    int   i;\n\n    if (!tokens || !tokens[0])\n        return (NULL);\n    result = gc_strdup(tokens[1]);\n    if (!result)\n        return (printf(\"Error\\nstrdup failed.\\n\"), NULL);\n    i = 2;\n    while (tokens[i])\n    {\n        tmp = gc_strjoin(result, \" \");\n        if (!tmp)\n            return (printf(\"Error\\nstrjoin failed.\\n\"), NULL);\n        if (!tmp)\n            return (NULL);\n        result = gc_strjoin(tmp, tokens[i]);\n        if (!result)\n            return (printf(\"Error\\nstrjoin failed.\\n\"), NULL);\n        i++;\n    }\n    return (result);\n}\n\nint process_fc(char **fc_tokens, t_config *config, int *current_line_done)\n{\n    char    *merged;\n    char    **rgb;\n    int     fields_count;\n    int     i;\n\n    i = 0;\n    fields_count = 0;\n    *current_line_done = 1;\n    if (!fc_tokens[1])\n        return (printf(\"Error\\nMissing rgb representation for %s\\n\", fc_tokens[0]), 0);\n    merged = join_tokens(fc_tokens);\n    if (!merged)\n        return (printf(\"Error\\nmalloc failed\\n\"), 0); \n    while (merged[i])\n    {\n        if (merged[i] == ',')\n            fields_count++;\n        i++;\n    }\n    if (fields_count != 2)\n        return (printf(\"Error\\nInvalid rgb representation\\n\"), 0);\n    rgb = gc_split(merged, ',');\n    if (!rgb)\n        return (printf(\"Error\\nft_split failed!\\n\"), 0);\n    if (!not_valid_num(rgb))\n        return (0);\n    if (ft_strcmp(fc_tokens[0], \"F\") == 0)\n        fill_color(config, F, rgb, current_line_done);\n    else if (ft_strcmp(fc_tokens[0], \"C\") == 0)\n        fill_color(config, C, rgb, current_line_done);\n    if (!(*current_line_done))\n        return (0);\n    return (1);\n}\n",
  "logic_parsing/map_config_tex.c": "#include \"cub3d.h\"\n\nstatic t_textures get_texture(char **tex_tokens, int *done)\n{\n    t_textures  t;\n    int         fd;\n    char        *raw_path; \n\n    memset(&t, 0, sizeof(t_textures));\n    if (!tex_tokens || !tex_tokens[0] || !tex_tokens[1])\n    {\n        *done = 0;\n        return ( printf(\"Error\\nInvalid texture line format. Expected 'IDENTIFIER PATH'.\\n\"), t);\n    }\n    raw_path = tex_tokens[1];\n    t.path = gc_strdup(raw_path);\n    if (!t.path)\n    {\n        *done = 0;\n        return (perror(\"Error\\nstrdup failed for texture path\"), t);\n    }\n    fd = open(t.path, O_RDONLY);\n    if (fd < 0)\n    {\n        *done = 0;\n        return (perror(\"Error\\nCannot open texture path\"), t);\n    }\n    close(fd);\n    *done = 1;\n    return (t);\n}\nstatic void    fill_config(t_config *config, t_co_type type, char **tex_tokens, int *current_line_done)\n{\n    t_textures temp_tex;\n\n    temp_tex = get_texture(tex_tokens, current_line_done);\n    if (*current_line_done == 0)\n        return;\n    if (type == NO)\n    {\n        if (config->no_tex.path != NULL) { printf(\"Error\\nDuplicate NO texture definition.\\n\"); *current_line_done = 0; return; }\n        config->no_tex = temp_tex;\n    }\n    else if (type == SO)\n    {\n        if (config->so_tex.path != NULL) { printf(\"Error\\nDuplicate SO texture definition.\\n\"); *current_line_done = 0; return; }\n        config->so_tex = temp_tex;\n    }\n    else if (type == EA)\n    {\n        if (config->ea_tex.path != NULL) { printf(\"Error\\nDuplicate EA texture definition.\\n\"); *current_line_done = 0; return; }\n        config->ea_tex = temp_tex;\n    }\n    else if (type == WE)\n    {\n        if (config->we_tex.path != NULL) { printf(\"Error\\nDuplicate WE texture definition.\\n\"); *current_line_done = 0; return; }\n        config->we_tex = temp_tex;\n    }\n}\n\nint process_tex(char **tex_tokens, t_config *config, int *current_line_done)\n{\n\n    *current_line_done = 0;\n    if (tex_tokens[2] != NULL)\n    {\n        printf(\"Error\\nToo many arguments on texture line '%s %s ...'\\n\", tex_tokens[0], tex_tokens[1]);\n        return (0);\n    }\n    if (ft_strcmp(tex_tokens[0], \"NO\") == 0)\n        fill_config(config, NO, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"SO\") == 0)\n        fill_config(config, SO, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"EA\") == 0)\n        fill_config(config, EA, tex_tokens, current_line_done);\n    else if (ft_strcmp(tex_tokens[0], \"WE\") == 0)\n        fill_config(config, WE, tex_tokens, current_line_done);\n    if (!(*current_line_done))\n        return (0);\n    return (1);\n}\n",
  "logic_parsing/map_data.c": "#include \"cub3d.h\"\nint is_map_char(char c)\n{\n    return (c == '0' || c == '1' || c == 'N' || c == 'S' || c == 'E' || c == 'W' || c == ' ');\n}\n\nint is_player_char(char c)\n{\n    return (c == 'N' || c == 'S' || c == 'E' || c == 'W');\n}\nstatic void add_line(t_game *game, char *line)\n{\n    char    **new_map;\n    size_t  i;\n\n    i = 0;\n    if (!game->map)\n    {\n        game->map = (char **)gc_mall(sizeof(char *) * 2);\n        if (!game->map)\n            (perror(\"Error\\nMalloc failed for map\"), exit(EXIT_FAILURE));\n        game->map[0] = gc_strdup(line);\n        if (!game->map[0])\n            (perror(\"Error\\nMalloc failed for map line\"), exit(EXIT_FAILURE));\n        game->map[1] = NULL;\n        game->map_height = 1;\n    }\n    else\n    {\n        new_map = (char **)gc_mall(sizeof(char *) * (game->map_height + 2));\n        if (!new_map)\n            (perror(\"Error\\nMalloc failed for map\"), exit(EXIT_FAILURE));\n        while (i < game->map_height)\n        {\n            new_map[i] = game->map[i];\n            i++;\n        }\n        new_map[i] = gc_strdup(line);\n        if (!new_map)\n            (perror(\"Error\\nMalloc failed for map line\"), exit(EXIT_FAILURE));\n        new_map[i + 1] = NULL;\n        game->map = new_map;\n        game->map_height++;\n    }\n    if (ft_strlen(line) > game->map_width)\n        game->map_width = ft_strlen(line);\n}\n\n\n\nstatic int validate_map_line(char *line, t_game *game)\n{\n    size_t  i;\n    \n    i = 0;\n    while (line[i])\n    {\n        if (!is_map_char(line[i]))\n            return (printf(\"Error\\nInvalid character in map: '%c'\\n\", line[i]), 0);\n        if (is_player_char(line[i]))\n        {\n            game->player_count++;\n            if (game->player_count > 1)\n                return (printf(\"Error\\nOnly one player start position is allowed in the map.\\n\"), 0);\n        }\n        if (line[i] == '0' || is_player_char(line[i]))\n        {\n            if (i > 0 && line[i - 1] == ' ')\n                return (printf(\"Error\\n'0' or player character surrounded by space on left.\\n\"), 0);\n            if (line[i + 1] == ' ')\n                return (printf(\"Error\\n'0' or player character surrounded by space on right.\\n\"), 0);\n        }\n        i++;\n    }\n    game->map_started = 1;\n    return (1);\n}\n\nint process_map(char *line, t_game *game)\n{\n    if (!validate_map_line(line, game))\n        return (0);\n    add_line(game, line);\n    return (1);\n}",
  "logic_parsing/map_data_helper.c": "#include \"cub3d.h\"\n\nstatic int check_column_edges(t_game *game)\n{\n    size_t c;\n\n    c = 0;\n    while (c < game->map_width)\n    {\n        if (c < ft_strlen(game->map[0]) &&\n            (game->map[0][c] == '0' || is_player_char(game->map[0][c])))\n            return (printf(\"Error\\nMap not closed (top edge).\\n\"), 0);\n        if (c < ft_strlen(game->map[game->map_height - 1]) &&\n            (game->map[game->map_height - 1][c] == '0' || \n            is_player_char(game->map[game->map_height - 1][c])))\n            return (printf(\"Error\\nMap not closed (bottom edge).\\n\"), 0);\n        c++;\n    }\n    return (1);\n}\n\nstatic int check_neighbor_edges(t_game *game, size_t *r)\n{\n    size_t  c;\n    char    current_char;\n\n    c = 0;\n    while (c < ft_strlen(game->map[(*r)]))\n    {\n        current_char = game->map[(*r)][c];\n        if (current_char == '0' || is_player_char(current_char))\n        {\n            if (r == 0 || (c >= ft_strlen(game->map[(*r) - 1]) ||\n                game->map[(*r) - 1][c] == ' ' || game->map[(*r) - 1][c] == '\\0'))\n                return (printf(\"Error\\nMap not closed (top neighbor of '0' or player).\\n\"), 0);\n            if ((*r) == game->map_height - 1 ||\n                (c >= ft_strlen(game->map[(*r) + 1]) ||\n                game->map[(*r) + 1][c] == ' ' || game->map[(*r) + 1][c] == '\\0'))\n                return (printf(\"Error\\nMap not closed (bottom neighbor of '0' or player).\\n\"), 0);\n            if (c == 0 || game->map[(*r)][c-1] == ' ')\n                return (printf(\"Error\\nMap not closed (left neighbor of '0' or player).\\n\"), 0);\n            if (c == ft_strlen(game->map[(*r)]) - 1 || game->map[(*r)][c+1] == ' ')\n                return (printf(\"Error\\nMap not closed (right neighbor of '0' or player).\\n\"), 0);\n        }\n        c++;\n    }\n    return (1);\n}\n\nint check_raw_edges(t_game *game)\n{\n    size_t  r;\n    size_t  c;\n    size_t  first_non_space;\n    size_t  last_non_space;\n\n    c = 0;\n    r = 0;\n    first_non_space = (size_t) - 1;\n    last_non_space = (size_t) - 1;\n    while (r < game->map_height)\n    {\n        c = 0;\n        while (c < ft_strlen(game->map[r]))\n        {\n            if (game->map[r][c] != ' ')\n            {\n                first_non_space = c;\n                break;\n            }\n            c++;    \n        }\n        if (first_non_space != (size_t) - 1 &&\n            (game->map[r][first_non_space] == '0' ||\n            is_player_char(game->map[r][first_non_space])))\n            return (printf(\"Error\\nMap not closed (left edge).\\n\"), 0);\n        c = ft_strlen(game->map[r]);\n        while (c > 0)\n        {\n            c--;\n            if (game->map[r][c] != ' ')\n            {\n                last_non_space = c;\n                break;\n            }\n        }\n        if (last_non_space != (size_t)-1 &&\n            (game->map[r][last_non_space] == '0' ||\n            is_player_char(game->map[r][last_non_space])))\n            return (printf(\"Error\\nMap not closed (right edge).\\n\"), 0); \n        if (!check_neighbor_edges(game, &r))\n            return (0);\n        r++;\n    }\n    return (1);\n}\n\nint check_map_closed(t_game *game)\n{\n    if (!check_column_edges(game))\n        return (0);\n    if (!check_raw_edges(game))\n        return (0);\n    return (1);\n}",
  "logic_parsing/player_cord.c": "#include \"cub3d.h\"\n\nstatic  int is_player_cord(char c)\n{\n    return (c == 'N' || c == 'S' || c == 'E' || c == 'W');\n}\nstatic void set_pos(t_player *player, char c)\n{\n    if (c == 'N')\n    {\n        player->dirX = 0;\n        player->dirY = -1;\n    }\n    else if (c == 'S')\n    {\n        player->dirX = 0;\n        player->dirY = 1;\n    }\n    else if (c == 'W')\n    {\n        player->dirX = -1;\n        player->dirY = 0;\n    }\n    else if (c == 'E')\n    {\n        player->dirX = 1;\n        player->dirY = 0;\n    }\n\n}\n\nstatic void set_plane(t_player *player)\n{\n    if (player->dirY == -1)\n    {\n        player->planeX = .66;\n        player->planeY = 0;\n    }\n    else if (player->dirY == 1)\n    {\n        player->planeX = -.66;\n        player->planeY = 0;\n    }\n    else if (player->dirX == -1)\n    {\n        player->planeX = 0;\n        player->planeY = -.66;\n    }\n    else if (player->dirX == 1)\n    {\n        player->planeX = 0;\n        player->planeY = .66;\n    }\n}\nvoid    get_player_cord(t_game *game)\n{\n    t_player    tmp_player;\n    size_t      r;\n    size_t      c;\n    \n    r = 0;\n    memset(&tmp_player, 0 , sizeof(t_player));\n    while (r < game->map_height)\n    {\n        c = 0;\n        while (c < ft_strlen(game->map[r]))\n        {\n            if (is_player_cord(game->map[r][c]))\n            {\n                tmp_player.posX = (double) c + .5;\n                tmp_player.posY = (double) r + .5;\n                set_pos(&tmp_player, game->map[r][c]);\n                set_plane(&tmp_player);\n                game->map[r][c] = '0';\n                game->player = tmp_player;\n                return;\n            }\n            c++;\n        }\n        r++;   \n    } \n}",
  "minilibx-linux/Makefile": "##\n## Makefile for MiniLibX in /home/boulon/work/c/raytraceur/minilibx\n## \n## Made by Olivier Crouzet\n## Login   <ol@epitech.net>\n## \n## Started on  Tue Oct  5 15:56:43 2004 Olivier Crouzet\n## Last update Tue May 15 15:44:41 2007 Olivier Crouzet\n##\n\n## Please use configure script\n\n\nall\t: do_configure\n\ndo_configure\t:\n\t./configure\n\nclean\t:\n\t./configure clean\n\nre\t: clean all\n",
  "minilibx-linux/mlx.h": "/*\n** mlx.h for MinilibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Jul 31 16:37:50 2000 Charlie Root\n** Last update Tue May 15 16:23:28 2007 Olivier Crouzet\n*/\n\n/*\n**   MinilibX -  Please report bugs\n*/\n\n\n/*\n** FR msg - FR msg - FR msg\n**\n** La MinilibX utilise 2 librairies supplementaires qu'il\n**      est necessaire de rajouter a la compilation :\n**   -lmlx -lXext -lX11\n**\n** La MinilibX permet le chargement des images de type Xpm.\n** Notez que cette implementation est incomplete.\n** Merci de communiquer tout probleme de chargement d'image\n** de ce type.\n*/\n\n\n#ifndef MLX_H\n\n#define\tMLX_H\n\n\nvoid\t*mlx_init();\n/*\n**  needed before everything else.\n**  return (void *)0 if failed\n*/\n\n\n/*\n** Basic actions\n*/\n\nvoid\t*mlx_new_window(void *mlx_ptr, int size_x, int size_y, char *title);\n/*\n**  return void *0 if failed\n*/\nint\tmlx_clear_window(void *mlx_ptr, void *win_ptr);\nint\tmlx_pixel_put(void *mlx_ptr, void *win_ptr, int x, int y, int color);\n/*\n**  origin for x & y is top left corner of the window\n**  y down is positive\n**  color is 0x00RRGGBB\n*/\n\n\n/*\n** Image stuff\n*/\n\nvoid\t*mlx_new_image(void *mlx_ptr,int width,int height);\n/*\n**  return void *0 if failed\n**  obsolete : image2 data is stored using bit planes\n**  void\t*mlx_new_image2(void *mlx_ptr,int width,int height);\n*/\nchar\t*mlx_get_data_addr(void *img_ptr, int *bits_per_pixel,\n\t\t\t   int *size_line, int *endian);\n/*\n**  endian : 0 = sever X is little endian, 1 = big endian\n**  for mlx_new_image2, 2nd arg of mlx_get_data_addr is number_of_planes\n*/\nint\tmlx_put_image_to_window(void *mlx_ptr, void *win_ptr, void *img_ptr,\n\t\t\t\tint x, int y);\nint\tmlx_get_color_value(void *mlx_ptr, int color);\n\n\n/*\n** dealing with Events\n*/\n\nint\tmlx_mouse_hook (void *win_ptr, int (*funct_ptr)(), void *param);\nint\tmlx_key_hook (void *win_ptr, int (*funct_ptr)(), void *param);\nint\tmlx_expose_hook (void *win_ptr, int (*funct_ptr)(), void *param);\n\nint\tmlx_loop_hook (void *mlx_ptr, int (*funct_ptr)(), void *param);\nint\tmlx_loop (void *mlx_ptr);\nint mlx_loop_end (void *mlx_ptr);\n\n/*\n**  hook funct are called as follow :\n**\n**   expose_hook(void *param);\n**   key_hook(int keycode, void *param);\n**   mouse_hook(int button, int x,int y, void *param);\n**   loop_hook(void *param);\n**\n*/\n\n\n/*\n**  Usually asked...\n*/\n\nint\tmlx_string_put(void *mlx_ptr, void *win_ptr, int x, int y, int color,\n\t\t       char *string);\nvoid\tmlx_set_font(void *mlx_ptr, void *win_ptr, char *name);\nvoid\t*mlx_xpm_to_image(void *mlx_ptr, char **xpm_data,\n\t\t\t  int *width, int *height);\nvoid\t*mlx_xpm_file_to_image(void *mlx_ptr, char *filename,\n\t\t\t       int *width, int *height);\nint\tmlx_destroy_window(void *mlx_ptr, void *win_ptr);\n\nint\tmlx_destroy_image(void *mlx_ptr, void *img_ptr);\n\nint\tmlx_destroy_display(void *mlx_ptr);\n\n/*\n**  generic hook system for all events, and minilibX functions that\n**    can be hooked. Some macro and defines from X11/X.h are needed here.\n*/\n\nint\tmlx_hook(void *win_ptr, int x_event, int x_mask,\n                 int (*funct)(), void *param);\n\nint\tmlx_do_key_autorepeatoff(void *mlx_ptr);\nint\tmlx_do_key_autorepeaton(void *mlx_ptr);\nint\tmlx_do_sync(void *mlx_ptr);\n\nint\tmlx_mouse_get_pos(void *mlx_ptr, void *win_ptr, int *x, int *y);\nint\tmlx_mouse_move(void *mlx_ptr, void *win_ptr, int x, int y);\nint\tmlx_mouse_hide(void *mlx_ptr, void *win_ptr);\nint\tmlx_mouse_show(void *mlx_ptr, void *win_ptr);\n\nint\tmlx_get_screen_size(void *mlx_ptr, int *sizex, int *sizey);\n\n#endif /* MLX_H */\n",
  "minilibx-linux/mlx_clear_window.c": "/*\n** mlx_clear_window.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Thu Sep  7 19:46:15 2000 Charlie Root\n** Last update Tue Sep 25 17:11:19 2001 Charlie Root\n*/\n\n\n\n#include\t\"mlx_int.h\"\n\n\nint\t\tmlx_clear_window(t_xvar *xvar,t_win_list *win)\n{\n  XClearWindow(xvar->display,win->window);\n  if (xvar->do_flush)\n    XFlush(xvar->display);\n}\n",
  "minilibx-linux/mlx_destroy_display.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   mlx_destroy_display.c                              :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: mg <mg@student.42.fr>                      +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2020/10/03 18:56:35 by mg                #+#    #+#             */\n/*   Updated: 2020/10/04 01:55:35 by mg               ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"mlx_int.h\"\n\nint\tmlx_destroy_display(t_xvar *xvar)\n{\n\tXCloseDisplay(xvar->display);\n}\n",
  "minilibx-linux/mlx_destroy_image.c": "/*\n** mlx_destroy_image.c for MinilibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Tue Mar 12 10:25:15 2002 Charlie Root\n** Last update Tue May 15 16:45:54 2007 Olivier Crouzet\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\nint\tmlx_destroy_image(t_xvar *xvar, t_img *img)\n{\n  if (img->type == MLX_TYPE_SHM_PIXMAP ||\n      img->type == MLX_TYPE_SHM)\n    {\n      XShmDetach(xvar->display, &(img->shm));\n      shmdt(img->shm.shmaddr);\n      /* shmctl IPC_RMID already done */\n    }\n  XDestroyImage(img->image);  /* For image & shm-image. Also free img->data */\n  XFreePixmap(xvar->display, img->pix);\n  if (img->gc)\n    XFreeGC(xvar->display, img->gc);\n  free(img);\n  if (xvar->do_flush)\n    XFlush(xvar->display);\n}\n",
  "minilibx-linux/mlx_destroy_window.c": "/*\n** mlx_destroy_window.c for MinilibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Tue Mar 12 10:25:15 2002 Charlie Root\n** Last update Tue May 15 16:46:08 2007 Olivier Crouzet\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\nint\tmlx_destroy_window(t_xvar *xvar,t_win_list *win)\n{\n  t_win_list\t*w;\n  t_win_list\t*prev;\n  t_win_list\tfirst;\n\n  first.next = xvar->win_list;\n  prev = &first;\n  w = prev->next;\n  while (w)\n    {\n      if (w==win)\n\tprev->next = w->next;\n      else\n\tprev = w;\n      w = w->next;\n    }\n  xvar->win_list = first.next;\n  XDestroyWindow(xvar->display,win->window);\n  XFreeGC(xvar->display,win->gc);\n  free(win);\n  if (xvar->do_flush)\n    XFlush(xvar->display);\n}\n",
  "minilibx-linux/mlx_expose_hook.c": "/*\n** mlx_expose_hook.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Thu Aug  3 11:49:06 2000 Charlie Root\n** Last update Fri Feb 23 17:07:42 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nint\t\tmlx_expose_hook(t_win_list *win,int (*funct)(),void *param)\n{\n  win->hooks[Expose].hook = funct;\n  win->hooks[Expose].param = param;\n  win->hooks[Expose].mask = ExposureMask;\n}\n",
  "minilibx-linux/mlx_ext_randr.c": "\n\n\n#include\t\"mlx_int.h\"\n\n#include\t<unistd.h>\n#include <X11/extensions/Xrandr.h>\n\n/* global for independant extension */\n\nRRMode\tsaved_mode = 0;\n\n\nint\t\t\tmlx_ext_fullscreen(t_xvar *xvar, t_win_list *win, int fullscreen)\n{\n  XWindowAttributes\twatt;\n  int\t\t\ti;\n  int\t\t\tj;\n  XRRScreenResources\t*res;\n  XRROutputInfo\t\t*o_info;\n  XRRCrtcInfo\t\t*crtc;\n  RRMode\t\tmode_candidate;\n  int\t\t\tidx_output;\n  int\t\t\tidx_candidate;\n\n  if (!XGetWindowAttributes(xvar->display, win->window, &watt))\n    return (0);\n\n  res = XRRGetScreenResources(xvar->display, xvar->root);\n  o_info = NULL;\n  idx_output = -1;\n  i = res->noutput;\n  while (i--)\n    {\n      o_info = XRRGetOutputInfo(xvar->display, res, res->outputs[i]);\n      if (o_info->connection == RR_Connected)\n\t{\n\t  idx_output = i;\n\t  i = 0;\n\t}\n      else\n\tXRRFreeOutputInfo(o_info);\n    }\n  if (!o_info)\n    {\n      XRRFreeScreenResources(res);\n      return (0);\n    }\n  \n  idx_candidate = -1;\n  i = o_info->nmode;\n  while (i--)\n    {\n      j = res->nmode;\n      while (j--)\n\tif (res->modes[j].id == o_info->modes[i])\n\t  if (res->modes[j].width >= watt.width && res->modes[j].height >= watt.height &&\n\t      (idx_candidate == -1 || res->modes[idx_candidate].width > res->modes[j].width ||\n\t       res->modes[idx_candidate].height > res->modes[j].height) )\n\t    idx_candidate = i;\n    }\n  if (idx_candidate < 0)\n    {\n      XRRFreeOutputInfo(o_info);\n      XRRFreeScreenResources(res);\n      return (0);\n    }\n  if (!fullscreen && saved_mode == -1)\n    idx_candidate = 0; /* if no clue, uses first mode, usually part of npreferred */\n  mode_candidate = o_info->modes[idx_candidate];\n  if (!fullscreen)\n    mode_candidate = saved_mode;\n\n  crtc = XRRGetCrtcInfo(xvar->display, res, o_info->crtc);\n  saved_mode = crtc->mode;\n\n  i = XRRSetCrtcConfig(xvar->display, res, o_info->crtc, CurrentTime, 0, 0, mode_candidate,\n\t\t       crtc->rotation, &res->outputs[idx_output], 1);\n  if (fullscreen)\n    printf(\"found mode : %d x %d\\n Status %d\\n\", res->modes[idx_candidate].width, res->modes[idx_candidate].height, i);\n  else\n    printf(\"back previous mode\\n\");\n  \n  XMoveWindow(xvar->display, win->window, 0, 0);\n  XMapRaised(xvar->display, win->window);\n\n  if (fullscreen)\n    {\n      //      XGrabPointer(xvar->display, win->window, True, 0, GrabModeAsync, GrabModeAsync, win->window, 0L, CurrentTime);\n      XGrabKeyboard(xvar->display, win->window, False, GrabModeAsync, GrabModeAsync, CurrentTime);\n    }\n  else\n    {\n      XUngrabPointer(xvar->display, CurrentTime);\n      XUngrabKeyboard(xvar->display, CurrentTime);\n    }\n\n  XSync(xvar->display, False);\n  sleep(1);\n\n  XRRFreeCrtcInfo(crtc);\n  XRRFreeOutputInfo(o_info);\n  XRRFreeScreenResources(res);\n}\n",
  "minilibx-linux/mlx_flush_event.c": "/*\n** mlx_flush_event.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Wed Aug  2 18:58:11 2000 Charlie Root\n** Last update Fri Feb 23 17:08:48 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nint\tmlx_flush_event(t_xvar *xvar)\n{\n  XEvent\tev;\n\n  while (XPending(xvar->display))\n  {\n     XNextEvent(xvar->display,&ev);\n  }\n}\n",
  "minilibx-linux/mlx_get_color_value.c": "/*\n** mlx_get_color_value.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Jul 31 19:01:33 2000 Charlie Root\n** Last update Thu Oct  4 15:04:13 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\nint             mlx_get_color_value(t_xvar *xvar,int color)\n{\n  return(mlx_int_get_good_color(xvar,color));\n}\n\nint\t\tmlx_int_get_good_color(t_xvar *xvar,int color)\n{\n  XColor\txc;\n\n  if (xvar->depth>=24)\n    return (color);\n  xc.red = (color>>8)&0xFF00;\n  xc.green = color&0xFF00;\n  xc.blue = (color<<8)&0xFF00;\n  xc.pixel = ((xc.red>>(16-xvar->decrgb[1]))<<xvar->decrgb[0])+\n    ((xc.green>>(16-xvar->decrgb[3]))<<xvar->decrgb[2])+\n    ((xc.blue>>(16-xvar->decrgb[5]))<<xvar->decrgb[4]);\n  return (xc.pixel);\n}\n",
  "minilibx-linux/mlx_get_data_addr.c": "/*\n** mlx_get_data_addr.c for MiniLibX in raytraceur\n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Aug 14 15:45:57 2000 Charlie Root\n** Last update Thu Sep 27 19:05:25 2001 Charlie Root\n*/\n\n\n\n#include\t\"mlx_int.h\"\n\n\nchar\t*mlx_get_data_addr(t_img *img,int *bits_per_pixel,\n\t\t\t   int *size_line,int *endian)\n{\n  *bits_per_pixel = img->bpp;\n  *size_line = img->size_line;\n  *endian = img->image->byte_order;\n  return (img->data);\n}\n",
  "minilibx-linux/mlx_hook.c": "/*\n** mlx_hook.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Thu Aug  3 11:49:06 2000 Charlie Root\n** Last update Fri Jan 28 17:05:28 2005 Olivier Crouzet\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nint\tmlx_hook(t_win_list *win, int x_event, int x_mask, \n\t\t int (*funct)(),void *param)\n{\n  win->hooks[x_event].hook = funct;\n  win->hooks[x_event].param = param;\n  win->hooks[x_event].mask = x_mask;\n}\n\n\nint\tmlx_do_key_autorepeatoff(t_xvar *xvar)\n{\n  XAutoRepeatOff(xvar->display);\n}\n\nint\tmlx_do_key_autorepeaton(t_xvar *xvar)\n{\n  XAutoRepeatOn(xvar->display);\n}\n\n\nint\tmlx_do_sync(t_xvar *xvar)\n{\n  XSync(xvar->display, False);\n}\n",
  "minilibx-linux/mlx_init.c": "/*\n** mlx_init.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Jul 31 16:52:42 2000 Charlie Root\n** Last update Fri Jan 28 17:05:09 2005 Olivier Crouzet\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\nvoid\t*mlx_init()\n{\n\tt_xvar\t*xvar;\n\t\n\tif (!(xvar = malloc(sizeof(*xvar))))\n\t\treturn ((void*)0);\n\tif ((xvar->display = XOpenDisplay(\"\")) == 0)\n\t{\n\t\tfree(xvar);\n\t\treturn ((void*)0);\n\t}\n\txvar->screen = DefaultScreen(xvar->display);\n\txvar->root = DefaultRootWindow(xvar->display);\n\txvar->cmap = DefaultColormap(xvar->display,xvar->screen);\n\txvar->depth = DefaultDepth(xvar->display,xvar->screen);\n\tif (mlx_int_get_visual(xvar)==-1)\n\t{\n\t\tprintf(ERR_NO_TRUECOLOR);\n\t\texit(1);\n\t}\n\txvar->win_list = 0;\n\txvar->loop_hook = 0;\n\txvar->loop_param = (void *)0;\n\txvar->do_flush = 1;\n\txvar->wm_delete_window = XInternAtom (xvar->display, \"WM_DELETE_WINDOW\", False);\n\txvar->wm_protocols = XInternAtom (xvar->display, \"WM_PROTOCOLS\", False);\n\tmlx_int_deal_shm(xvar);\n\tif (xvar->private_cmap)\n\t\txvar->cmap = XCreateColormap(xvar->display,xvar->root,\n\t\t\t\t xvar->visual,AllocNone);\n\tmlx_int_rgb_conversion(xvar);\n\txvar->end_loop = 0;\n\treturn (xvar);\n}\n\n\n/*\n** pshm_format of -1 :\tNot XYBitmap|XYPixmap|ZPixmap\n** alpha libX need a check of the DISPLAY env var, or shm is allowed\n** in remote Xserver connections.\n*/\n\nint\t\tmlx_int_deal_shm(t_xvar *xvar)\n{\n\tint\t\tuse_pshm;\n\tint\t\tbidon;\n\tchar\t*dpy;\n\tchar\tbuff[33];\n\n\txvar->use_xshm = XShmQueryVersion(xvar->display,&bidon,&bidon,&(use_pshm));\n\tif (xvar->use_xshm && use_pshm)\n\t\txvar->pshm_format = XShmPixmapFormat(xvar->display);\n\telse\n\t\txvar->pshm_format = -1;\n\tgethostname(buff,32);\n\tdpy = getenv(ENV_DISPLAY);\n\tif (dpy && strlen(dpy) && *dpy!=':' && strncmp(dpy,buff,strlen(buff)) &&\n\t\t\tstrncmp(dpy,LOCALHOST,strlen(LOCALHOST)) )\n\t{\n\t\txvar->pshm_format = -1;\n\t\txvar->use_xshm = 0;\n\t}\n}\n\n/*\n** TrueColor Visual is needed to have *_mask correctly set\n*/\n\nint\t\tmlx_int_rgb_conversion(t_xvar *xvar)\n{\n\tbzero(xvar->decrgb,sizeof(int)*6);\n\twhile (!(xvar->visual->red_mask&1))\n\t\t{ xvar->visual->red_mask >>= 1; xvar->decrgb[0] ++; }\n\twhile (xvar->visual->red_mask&1)\n\t\t{ xvar->visual->red_mask >>= 1; xvar->decrgb[1] ++; }\n\twhile (!(xvar->visual->green_mask&1))\n\t\t{ xvar->visual->green_mask >>= 1; xvar->decrgb[2] ++; }\n\twhile (xvar->visual->green_mask&1)\n\t\t{ xvar->visual->green_mask >>= 1; xvar->decrgb[3] ++; }\n\twhile (!(xvar->visual->blue_mask&1))\n\t\t{ xvar->visual->blue_mask >>= 1; xvar->decrgb[4] ++; }\n\twhile (xvar->visual->blue_mask&1)\n\t\t{ xvar->visual->blue_mask >>= 1; xvar->decrgb[5] ++; }\n}\n",
  "minilibx-linux/mlx_int.h": "/*\n** mlx_int.h for mlx in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Jul 31 16:45:48 2000 Charlie Root\n** Last update Wed May 25 16:44:16 2011 Olivier Crouzet\n*/\n\n\n\n/*\n** Internal settings for MiniLibX\n*/\n\n#ifndef MLX_INT_H\n\n# define MLX_INT_H\n\n# include <stdlib.h>\n# include <stdio.h>\n# include <string.h>\n# include <unistd.h>\n# include <fcntl.h>\n# include <sys/mman.h>\n# include <X11/Xlib.h>\n# include <X11/Xutil.h>\n# include <sys/ipc.h>\n# include <sys/shm.h>\n# include <X11/extensions/XShm.h>\n# include <X11/XKBlib.h>\n/* #include\t<X11/xpm.h> */\n\n\n# define MLX_TYPE_SHM_PIXMAP 3\n# define MLX_TYPE_SHM 2\n# define MLX_TYPE_XIMAGE 1\n\n# define MLX_MAX_EVENT LASTEvent\n\n\n# define ENV_DISPLAY \"DISPLAY\"\n# define LOCALHOST \"localhost\"\n# define ERR_NO_TRUECOLOR \"MinilibX Error : No TrueColor Visual available.\\n\"\n# define WARN_SHM_ATTACH \"MinilibX Warning : X server can't attach shared memory.\\n\"\n\n\ntypedef\tstruct\ts_xpm_col\n{\n\tint\t\tname;\n\tint\t\tcol;\n}\t\t\t\tt_xpm_col;\n\n\nstruct\ts_col_name\n{\n\tchar\t*name;\n\tint\t\tcolor;\n};\n\ntypedef struct\ts_event_list\n{\n\tint\t\tmask;\n\tint\t\t(*hook)();\n\tvoid\t*param;\n}\t\t\t\tt_event_list;\n\n\ntypedef struct\ts_win_list\n{\n\tWindow\t\t\t\twindow;\n\tGC\t\t\t\t\tgc;\n\tstruct s_win_list\t*next;\n\tint\t\t\t\t\t(*mouse_hook)();\n\tint\t\t\t\t\t(*key_hook)();\n\tint\t\t\t\t\t(*expose_hook)();\n\tvoid\t\t\t\t*mouse_param;\n\tvoid\t\t\t\t*key_param;\n\tvoid\t\t\t\t*expose_param;\n\tt_event_list\t\thooks[MLX_MAX_EVENT];\n}\t\t\t\tt_win_list;\n\n\ntypedef struct\ts_img\n{\n\tXImage\t\t\t*image;\n\tPixmap\t\t\tpix;\n\tGC\t\t\t\tgc;\n\tint\t\t\t\tsize_line;\n\tint\t\t\t\tbpp;\n\tint\t\t\t\twidth;\n\tint\t\t\t\theight;\n\tint\t\t\t\ttype;\n\tint\t\t\t\tformat;\n\tchar\t\t\t*data;\n\tXShmSegmentInfo\tshm;\n}\t\t\t\tt_img;\n\ntypedef struct\ts_xvar\n{\n\tDisplay\t\t*display;\n\tWindow\t\troot;\n\tint\t\t\tscreen;\n\tint\t\t\tdepth;\n\tVisual\t\t*visual;\n\tColormap\tcmap;\n\tint\t\t\tprivate_cmap;\n\tt_win_list\t*win_list;\n\tint\t\t\t(*loop_hook)();\n\tvoid\t\t*loop_param;\n\tint\t\t\tuse_xshm;\n\tint\t\t\tpshm_format;\n\tint\t\t\tdo_flush;\n\tint\t\t\tdecrgb[6];\n\tAtom\t\twm_delete_window;\n\tAtom\t\twm_protocols;\n\tint \t\tend_loop;\n}\t\t\t\tt_xvar;\n\n\nint\t\t\t\tmlx_int_do_nothing();\nint\t\t\t\tmlx_get_color_value();\nint\t\t\t\tmlx_int_get_good_color();\nint\t\t\t\tmlx_int_find_in_pcm();\nint\t\t\t\tmlx_int_anti_resize_win();\nint\t\t\t\tmlx_int_wait_first_expose();\nint\t\t\t\tmlx_int_rgb_conversion();\nint\t\t\t\tmlx_int_deal_shm();\nvoid\t\t\t*mlx_int_new_xshm_image();\nchar\t\t\t**mlx_int_str_to_wordtab();\nvoid\t\t\t*mlx_new_image();\nint\t\t\t\tshm_att_pb();\nint\t\t\t\tmlx_int_get_visual(t_xvar *xvar);\nint\t\t\t\tmlx_int_set_win_event_mask(t_xvar *xvar);\nint\t\t\t\tmlx_int_str_str_cote(char *str,char *find,int len);\nint\t\t\t\tmlx_int_str_str(char *str,char *find,int len);\n\n\n#endif\n",
  "minilibx-linux/mlx_int_anti_resize_win.c": "/*\n** mlx_int_anti_resize_win.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Tue Aug  8 14:31:05 2000 Charlie Root\n** Last update Tue Sep 25 15:56:58 2001 Charlie Root\n*/\n\n#include\t\"mlx_int.h\"\n\n\nint\tmlx_int_anti_resize_win(t_xvar *xvar,Window win,int w,int h)\n{\n  XSizeHints    hints;\n  long\t\ttoto;\n  \n  XGetWMNormalHints(xvar->display,win,&hints,&toto);\n  hints.width = w;\n  hints.height = h;\n  hints.min_width = w;\n  hints.min_height = h;\n  hints.max_width = w;\n  hints.max_height = h;\n  hints.flags = PPosition | PSize | PMinSize | PMaxSize;\n  XSetWMNormalHints(xvar->display,win,&hints);\n}\n",
  "minilibx-linux/mlx_int_do_nothing.c": "/*\n** mlx_int_do_nothing.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Tue Aug  8 12:58:24 2000 Charlie Root\n** Last update Tue Sep 25 15:56:22 2001 Charlie Root\n*/\n\n\n\nint\tmlx_int_do_nothing(void *param)\n{\n  \n}\n",
  "minilibx-linux/mlx_int_get_visual.c": "/*\n** mlx_int_get_visual.c for MinilibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Wed Oct  3 17:01:51 2001 Charlie Root\n** Last update Thu Oct  4 15:00:45 2001 Charlie Root\n*/\n\n\n\n#include\t\"mlx_int.h\"\n\n\n/*\n** We need a private colormap for non-default Visual.\n*/\n\n\nint\t\tmlx_int_get_visual(t_xvar *xvar)\n{\n  XVisualInfo\t*vi;\n  XVisualInfo\ttemplate;\n  int\t\tnb_item;\n\n  xvar->private_cmap = 0;\n  xvar->visual = DefaultVisual(xvar->display,xvar->screen);\n  if (xvar->visual->class == TrueColor)\n    return (0);\n  template.class = TrueColor;\n  template.depth = xvar->depth;\n  if (!(vi = XGetVisualInfo(xvar->display,VisualDepthMask|VisualClassMask,\n\t\t\t    &template,&nb_item)) )\n    return (-1);\n  xvar->visual = vi->visual;\n  xvar->private_cmap = 1;\n  return (0);\n}\n",
  "minilibx-linux/mlx_int_param_event.c": "/*\n** mlx_int_param_event.c for MinilibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Jul 31 16:37:50 2000 Charlie Root\n** Last update Wed Oct  6 13:14:52 2004 Olivier Crouzet\n*/\n\n#include\t\"mlx_int.h\"\n\nint\tmlx_int_param_undef()\n{\n}\n\nint\tmlx_int_param_KeyPress(t_xvar *xvar, XEvent *ev, t_win_list *win)\n{\n  win->hooks[KeyPress].hook(XkbKeycodeToKeysym(xvar->display,\n\t\t\t\t\t       ev->xkey.keycode, 0, 0),\n\t\t\t    win->hooks[KeyPress].param);\n}\n\nint\tmlx_int_param_KeyRelease(t_xvar *xvar, XEvent *ev, t_win_list *win)\n{\n  win->hooks[KeyRelease].hook(XkbKeycodeToKeysym(xvar->display,\n\t\t\t\t\t\t ev->xkey.keycode, 0, 0),\n\t\t\t      win->hooks[KeyRelease].param);\n}\n\nint\tmlx_int_param_ButtonPress(t_xvar *xvar, XEvent *ev, t_win_list *win)\n{\n  win->hooks[ButtonPress].hook(ev->xbutton.button,ev->xbutton.x,ev->xbutton.y,\n\t\t\t       win->hooks[ButtonPress].param);\n}\n\nint\tmlx_int_param_ButtonRelease(t_xvar *xvar, XEvent *ev, t_win_list *win)\n{\n  win->hooks[ButtonRelease].hook(ev->xbutton.button,\n\t\t\t\t ev->xbutton.x, ev->xbutton.y,\n\t\t\t\t win->hooks[ButtonRelease].param);\n}\n\nint\tmlx_int_param_MotionNotify(t_xvar *xvar, XEvent *ev, t_win_list *win)\n{\n  win->hooks[MotionNotify].hook(ev->xbutton.x,ev->xbutton.y,\n\t\t\t\twin->hooks[MotionNotify].param);\n}\n\nint\tmlx_int_param_Expose(t_xvar *xvar, XEvent *ev, t_win_list *win)\n{\n  if (!ev->xexpose.count)\n    win->hooks[Expose].hook(win->hooks[Expose].param);\n}\n\n\nint\tmlx_int_param_generic(t_xvar *xvar, XEvent *ev, t_win_list *win)\n{\n  win->hooks[ev->type].hook(win->hooks[ev->type].param);\n}\n\nint\t(*(mlx_int_param_event[]))() =\n{\n  mlx_int_param_undef,   /* 0 */\n  mlx_int_param_undef,\n  mlx_int_param_KeyPress,\n  mlx_int_param_KeyRelease,  /* 3 */\n  mlx_int_param_ButtonPress,\n  mlx_int_param_ButtonRelease,\n  mlx_int_param_MotionNotify,  /* 6 */\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_Expose,   /* 12 */\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic,\n  mlx_int_param_generic\n};\n",
  "minilibx-linux/mlx_int_set_win_event_mask.c": "/*\n** mlx_int_set_win_event_mask.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Thu Aug  3 11:49:06 2000 Charlie Root\n** Last update Fri Feb 23 17:07:42 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nint\tmlx_int_set_win_event_mask(t_xvar *xvar)\n{\n  t_win_list\t*win;\n  int\t\tmask;\n  int\t\ti;\n  XSetWindowAttributes\txwa;\n\n  win = xvar->win_list;\n  while (win)\n    {\n      xwa.event_mask = 0;\n      i = MLX_MAX_EVENT;\n      while (i--)\n\txwa.event_mask |= win->hooks[i].mask;\n      XChangeWindowAttributes(xvar->display, win->window, CWEventMask, &xwa);\n      win = win->next;\n    }\n}\n",
  "minilibx-linux/mlx_int_str_to_wordtab.c": "/*\n** mlx_int_str_to_wordtab.c for MinilibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Wed Sep 13 11:36:09 2000 Charlie Root\n** Last update Fri Dec 14 11:02:09 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\nint\tmlx_int_str_str(char *str,char *find,int len)\n{\n  int\tlen_f;\n  int\tpos;\n  char\t*s;\n  char\t*f;\n\n  len_f = strlen(find);\n  if (len_f>len)\n    return (-1);\n  pos = 0;\n  while (*(str+len_f-1))\n    {\n      s = str;\n      f = find;\n      while (*(f++) == *(s++))\n        if (!*f)\n          return (pos);\n      str ++;\n      pos ++;\n    }\n  return (-1);\n}\n\n\n\nint\tmlx_int_str_str_cote(char *str,char *find,int len)\n{\n  int\tlen_f;\n  int\tpos;\n  char\t*s;\n  char\t*f;\n  int\tcote;\n\n  len_f = strlen(find);\n  if (len_f>len)\n    return (-1);\n  cote = 0;\n  pos = 0;\n  while (*(str+len_f-1))\n    {\n      if (*str=='\"')\n\tcote = 1-cote;\n      if (!cote)\n\t{\n\t  s = str;\n\t  f = find;\n\t  while (*(f++) == *(s++))\n\t    if (!*f)\n\t      return (pos);\n\t}\n      str ++;\n      pos ++;\n    }\n  return (-1);\n}\n\n\nchar\t**mlx_int_str_to_wordtab(char *str)\n{\n  char\t**tab;\n  int\tpos;\n  int\tnb_word;\n  int\tlen;\n\n  len = strlen(str);\n  nb_word = 0;\n  pos = 0;\n  while (pos<len)\n  {\n    while (*(str+pos)==' ' || *(str+pos)=='\\t')\n      pos ++;\n    if (*(str+pos))\n      nb_word ++;\n    while (*(str+pos) && *(str+pos)!=' ' && *(str+pos)!='\\t')\n      pos ++;\n  }\n  if (!(tab = malloc((1+nb_word)*sizeof(*tab))))\n    return ((char **)0);\n  nb_word = 0;\n  pos = 0;\n  while (pos<len)\n    {\n      while (*(str+pos)==' ' || *(str+pos)=='\\t')\n\t{\n\t  *(str+pos) = 0;\n\t  pos ++;\n\t}\n      if (*(str+pos))\n\t{\n\t  tab[nb_word] = str+pos;\n\t  nb_word ++;\n\t}\n      while (*(str+pos) && *(str+pos)!=' ' && *(str+pos)!='\\t')\n\tpos ++;\n    }\n  tab[nb_word] = 0;\n  return (tab);\n}\n",
  "minilibx-linux/mlx_int_wait_first_expose.c": "/*\n** mlx_int_wait_first_expose.c for minilibx in \n** \n** Made by olivier crouzet\n** Login   <ol@epita.fr>\n** \n** Started on  Tue Oct 17 09:26:45 2000 olivier crouzet\n** Last update Fri Feb 23 17:27:10 2001 Charlie Root\n*/\n\n\n\n#include\t\"mlx_int.h\"\n\n\n\nint\tmlx_int_wait_first_expose(t_xvar *xvar,Window win)\n{\n  XEvent\tev;\n\n  XWindowEvent(xvar->display,win,ExposureMask,&ev);\n  XPutBackEvent(xvar->display,&ev);\n}\n",
  "minilibx-linux/mlx_key_hook.c": "/*\n** mlx_key_hook.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Thu Aug  3 11:49:06 2000 Charlie Root\n** Last update Fri Feb 23 17:10:09 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nint\t\tmlx_key_hook(t_win_list *win,int (*funct)(),void *param)\n{\n  win->hooks[KeyRelease].hook = funct;\n  win->hooks[KeyRelease].param = param;\n  win->hooks[KeyRelease].mask = KeyReleaseMask;\n}\n",
  "minilibx-linux/mlx_lib_xpm.c": "/*\n** mlx_xpm.c for minilibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Fri Dec  8 11:07:24 2000 Charlie Root\n** Last update Thu Oct  4 16:00:22 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nvoid\t\t*mlx_int_xpm_f_image(t_xvar *xvar,int *width,int *height,\n\t\t\t\t     int (*xpm_func)(),void *param)\n{\n  XImage\t*img1;\n  XImage\t*img2;\n  t_img\t\t*im2;\n  XpmAttributes\txpm_att;\n\n  xpm_att.visual = xvar->visual;\n  xpm_att.colormap = xvar->cmap;\n  xpm_att.depth = xvar->depth;\n  xpm_att.bitmap_format = ZPixmap;\n  xpm_att.valuemask = XpmDepth|XpmBitmapFormat|XpmVisual|XpmColormap;\n  if (xpm_func(xvar->display,param,&img1,&img2,&xpm_att))\n    return ((void *)0);\n  if (img2)\n    XDestroyImage(img2);\n\n  if (!(im2 = (void *)mlx_new_image(xvar,img1->width,img1->height)))\n    {\n      XDestroyImage(img1);\n      return ((void *)0);\n    }\n  *width = img1->width;\n  *height = img1->height;\n  if (mlx_int_egal_img(im2->image,img1))\n    {\n      bcopy(img1->data,im2->data,img1->height*img1->bytes_per_line);\n      XDestroyImage(img1);\n      return (im2);\n    }\n  if (im2->type==MLX_TYPE_SHM_PIXMAP)\n    {\n      XFreePixmap(xvar->display,im2->pix);\n      im2->pix = XCreatePixmap(xvar->display,xvar->root,\n\t\t\t       *width,*height,xvar->depth);\n    }\n  if (im2->type>MLX_TYPE_XIMAGE)\n    {\n      XShmDetach(xvar->display,&(im2->shm));\n      shmdt(im2->data);\n    }\n  XDestroyImage(im2->image);\n  im2->image = img1;\n  im2->data = img1->data;\n  im2->type = MLX_TYPE_XIMAGE;\n  im2->size_line = img1->bytes_per_line;\n  im2->bpp = img1->bits_per_pixel;\n  return (im2);\n}\n\n\nint\tmlx_int_egal_img(XImage *img1,XImage *img2)\n{\n  if (img1->width!=img2->width || img1->height!=img2->height ||\n      img1->xoffset!=img2->xoffset || img1->format!=img2->format ||\n      img1->byte_order!=img2->byte_order ||\n      img1->bitmap_unit!=img2->bitmap_unit ||\n      img1->bitmap_bit_order!=img2->bitmap_bit_order ||\n      img1->bitmap_pad!=img2->bitmap_pad || img1->depth!=img2->depth ||\n      img1->bytes_per_line!=img2->bytes_per_line ||\n      img1->bits_per_pixel!=img2->bits_per_pixel ||\n      img1->red_mask!=img2->red_mask || img1->green_mask!=img2->green_mask ||\n      img1->blue_mask!=img2->blue_mask )\n    return (0);\n  return (1);\n}\n\n\nvoid\t*mlx_xpm_file_to_image(t_xvar *xvar,char *filename,\n\t\t\t       int *width,int *height)\n{\n  return (mlx_int_xpm_f_image(xvar,width,height,XpmReadFileToImage,filename));\n}\n\n\nvoid\t*mlx_xpm_to_image(t_xvar *xvar,char **data,int *width,int *height)\n{\n  return (mlx_int_xpm_f_image(xvar,width,height,XpmCreateImageFromData,(void *)data));\n}\n",
  "minilibx-linux/mlx_loop.c": "/*\n** mlx_loop.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Wed Aug  2 18:58:11 2000 Charlie Root\n** Last update Fri Sep 30 14:47:41 2005 Olivier Crouzet\n*/\n\n\n#include\t\"mlx_int.h\"\n\nextern int\t(*(mlx_int_param_event[]))();\n\nstatic int\twin_count(t_xvar *xvar)\n{\n\tint\t\t\ti;\n\tt_win_list\t*win;\n\n\ti = 0;\n\twin = xvar->win_list;\n\twhile (win)\n\t{\n\t\twin = win->next;\n\t\t++i;\n\t}\n\treturn (i);\n}\n\nint\t\t\tmlx_loop_end(t_xvar *xvar)\n{\n\txvar->end_loop = 1;\n\treturn (1);\n}\n\nint\t\t\tmlx_loop(t_xvar *xvar)\n{\n\tXEvent\t\tev;\n\tt_win_list\t*win;\n\n\tmlx_int_set_win_event_mask(xvar);\n\txvar->do_flush = 0;\n\twhile (win_count(xvar) && !xvar->end_loop)\n\t{\n\t\twhile (!xvar->end_loop && (!xvar->loop_hook || XPending(xvar->display)))\n\t\t{\n\t\t\tXNextEvent(xvar->display,&ev);\n\t\t\twin = xvar->win_list;\n\t\t\twhile (win && (win->window!=ev.xany.window))\n\t\t\t\twin = win->next;\n\n\t\t\tif (win && ev.type == ClientMessage && ev.xclient.message_type == xvar->wm_protocols && ev.xclient.data.l[0] == xvar->wm_delete_window && win->hooks[DestroyNotify].hook)\n\t\t\t\twin->hooks[DestroyNotify].hook(win->hooks[DestroyNotify].param);\n\t\t\tif (win && ev.type < MLX_MAX_EVENT && win->hooks[ev.type].hook)\n\t\t\t\tmlx_int_param_event[ev.type](xvar, &ev, win);\n\t\t}\n\t\tXSync(xvar->display, False);\n\t\tif (xvar->loop_hook)\n\t\t\txvar->loop_hook(xvar->loop_param);\n\t}\n\treturn (0);\n}\n",
  "minilibx-linux/mlx_loop_hook.c": "/*\n** mlx_loop_hook.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Thu Aug  3 11:49:06 2000 Charlie Root\n** Last update Fri Feb 23 17:11:39 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nint\tmlx_loop_hook(t_xvar *xvar,int (*funct)(),void *param)\n{\n  xvar->loop_hook = funct;\n  xvar->loop_param = param;\n}\n",
  "minilibx-linux/mlx_mouse.c": "#include \"mlx_int.h\"\n\nint\t\tmlx_mouse_move(t_xvar *xvar, t_win_list *win, int x, int y)\n{\n\tXWarpPointer(xvar->display, None, win->window, 0, 0, 0, 0, x, y);\n\treturn (0);\n}\n\nint\t\tmlx_mouse_hide(t_xvar *xvar, t_win_list *win)\n{\n\tstatic char data[1] = {0};\n\tCursor cursor;\n\tPixmap blank;\n\tXColor dummy;\n\n\tblank = XCreateBitmapFromData(xvar->display, win->window, data, 1, 1);\n\tcursor = XCreatePixmapCursor(xvar->display, blank, blank, &dummy, &dummy, 0, 0);\n\tXDefineCursor(xvar->display, win->window, cursor);\n\tXFreePixmap(xvar->display, blank);\n\tXFreeCursor(xvar->display, cursor);\n}\n\nint\t\tmlx_mouse_show(t_xvar *xvar, t_win_list *win)\n{\n\tXUndefineCursor(xvar->display, win->window);\n}\n\n/*\n** Queries the position of the mouse pointer relative to the origin of the\n** specified window and saves it to the provided location.\n**\n** If the pointer is not on the same screen as the specified window, both\n** win_x_return and win_y_return are set to zero and the function returns 0.\n*/\n\nint\t\tmlx_mouse_get_pos(t_xvar *xvar, t_win_list *win, \\\n\t\t\tint *win_x_return, int *win_y_return)\n{\n\tWindow\t\troot_return;\n\tWindow\t\tchild_return;\n\tint\t\t\troot_x_return;\n\tint\t\t\troot_y_return;\n\tunsigned\tmask_return;\n\n\treturn (XQueryPointer(xvar->display, win->window, \\\n\t\t&root_return, &child_return, &root_x_return, &root_y_return, \\\n\t\twin_x_return, win_y_return, &mask_return));\n}\n",
  "minilibx-linux/mlx_mouse_hook.c": "/*\n** mlx_mouse_hook.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Thu Aug  3 11:49:06 2000 Charlie Root\n** Last update Fri Feb 23 17:11:05 2001 Charlie Root\n*/\n\n\n#include\t\"mlx_int.h\"\n\n\n\n\nint\t\tmlx_mouse_hook(t_win_list *win,int (*funct)(),void *param)\n{\n  win->hooks[ButtonPress].hook = funct;\n  win->hooks[ButtonPress].param = param;\n  win->hooks[ButtonPress].mask = ButtonPressMask;\n}\n",
  "minilibx-linux/mlx_new_image.c": "/*\n** mlx_new_image.c for MiniLibX in raytraceur\n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Aug 14 15:29:14 2000 Charlie Root\n** Last update Wed May 25 16:46:31 2011 Olivier Crouzet\n*/\n\n\n\n\n#include\t\"mlx_int.h\"\n\n/*\n** To handle X errors\n*/\n\n#define\tX_ShmAttach\t1\n\nint\tmlx_X_error;\n\nint\tshm_att_pb(Display *d,XErrorEvent *ev)\n{\n  if (ev->request_code==146 && ev->minor_code==X_ShmAttach)\n    write(2,WARN_SHM_ATTACH,strlen(WARN_SHM_ATTACH));\n  mlx_X_error = 1;\n}\n\n\n/*\n**  Data malloc :  width+32 ( bitmap_pad=32 ),    *4 = *32 / 8bit\n*/\n\n\nvoid\t*mlx_int_new_xshm_image(t_xvar *xvar,int width,int height,int format)\n{\n  t_img\t*img;\n  int\t(*save_handler)();\n\n  if (!(img = malloc(sizeof(*img))))\n    return ((void *)0);\n  bzero(img,sizeof(*img));\n  img->data = 0;\n  img->image = XShmCreateImage(xvar->display,xvar->visual,xvar->depth,\n\t\t\t       format,img->data,&(img->shm),width,height);\n  if (!img->image)\n    {\n      free(img);\n      return ((void *)0);\n    }\n  img->width = width;\n  img->height = height;\n  img->size_line = img->image->bytes_per_line;\n  img->bpp = img->image->bits_per_pixel;\n  img->format = format;\n  img->shm.shmid = shmget(IPC_PRIVATE,(width+32)*height*4,IPC_CREAT|0777);\n  if (img->shm.shmid==-1)\n    {\n      XDestroyImage(img->image);\n      free(img);\n      return ((void *)0);\n    }\n  img->data = img->shm.shmaddr = img->image->data = shmat(img->shm.shmid,0,0);\n  if (img->data==(void *)-1)\n    {\n      shmctl(img->shm.shmid,IPC_RMID,0);\n      XDestroyImage(img->image);\n      free(img);\n      return ((void *)0);\n    }\n  img->shm.readOnly = False;\n  mlx_X_error = 0;\n  save_handler = XSetErrorHandler(shm_att_pb);\n  if (!XShmAttach(xvar->display,&(img->shm)) ||\n      0&XSync(xvar->display,False) || mlx_X_error)\n    {\n      XSetErrorHandler(save_handler);\n      shmdt(img->data);\n      shmctl(img->shm.shmid,IPC_RMID,0);\n      XDestroyImage(img->image);\n      free(img);\n      return ((void *)0);\n    }\n  XSetErrorHandler(save_handler);\n  shmctl(img->shm.shmid,IPC_RMID,0);\n  if (xvar->pshm_format==format)\n    {\n      img->pix = XShmCreatePixmap(xvar->display,xvar->root,img->shm.shmaddr,\n\t\t\t\t  &(img->shm),width,height,xvar->depth);\n      img->type = MLX_TYPE_SHM_PIXMAP;\n    }\n  else\n    {\n      img->pix = XCreatePixmap(xvar->display,xvar->root,\n\t\t\t       width,height,xvar->depth);\n      img->type = MLX_TYPE_SHM;\n    }\n  if (xvar->do_flush)\n    XFlush(xvar->display);\n  return (img);\n}\n\n\n\nvoid\t*mlx_int_new_image(t_xvar *xvar,int width, int height,int format)\n{\n  t_img\t*img;\n\n  if (!(img = malloc(sizeof(*img))))\n    return ((void *)0);\n  if (!(img->data = malloc((width+32)*height*4)))\n  {\n    free(img);\n    return ((void *)0);\n  }\n  bzero(img->data,(width+32)*height*4);\n  img->image = XCreateImage(xvar->display,xvar->visual,xvar->depth,format,0,\n\t\t\t    img->data,width,height,32,0);\n  if (!img->image)\n    {\n      free(img->data);\n      free(img);\n      return ((void *)0);\n    }\n  img->gc = 0;\n  img->size_line = img->image->bytes_per_line;\n  img->bpp = img->image->bits_per_pixel;\n  img->width = width;\n  img->height = height;\n  img->pix = XCreatePixmap(xvar->display,xvar->root,width,height,xvar->depth);\n  img->format = format;\n  img->type = MLX_TYPE_XIMAGE;\n  if (xvar->do_flush)\n    XFlush(xvar->display);\n  return (img);\n}\n\n\nvoid\t*mlx_new_image(t_xvar *xvar,int width, int height)\n{\n  t_img\t*img;\n\n  if (xvar->use_xshm)\n    if (img = mlx_int_new_xshm_image(xvar,width,height,ZPixmap))\n      return (img);\n  return (mlx_int_new_image(xvar,width,height,ZPixmap));\n}\n\nvoid\t*mlx_new_image2(t_xvar *xvar,int width, int height)\n{\n  t_img\t*img;\n\n  if (xvar->use_xshm)\n    if (img = mlx_int_new_xshm_image(xvar,width,height,XYPixmap))\n      return (img);\n  return (mlx_int_new_image(xvar,width,height,XYPixmap));\n}\n",
  "minilibx-linux/mlx_new_window.c": "/*\n** mlx_new_window.c for MiniLibX in \n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Jul 31 17:29:02 2000 Charlie Root\n** Last update Thu Oct  4 15:44:43 2001 Charlie Root\n*/\n\n\n/*\n** We do not use White/BlackPixel macro, TrueColor Visual make sure\n** 0 is black & -1 is white\n**\n** With mlx_int_wait_first_expose, no flush is needed.\n*/\n\n#include\t\"mlx_int.h\"\n\n\nvoid\t*mlx_new_window(t_xvar *xvar,int size_x,int size_y,char *title)\n{\n\tt_win_list\t\t\t\t*new_win;\n\tXSetWindowAttributes\txswa;\n\tXGCValues\t\t\t\txgcv;\n\n\txswa.background_pixel = 0;\n\txswa.border_pixel = -1;\n\txswa.colormap = xvar->cmap;\n\t/*\n\txswa.event_mask = ButtonPressMask | ButtonReleaseMask | ExposureMask |\n\t\tKeyPressMask | KeyReleaseMask | StructureNotifyMask;\n\t*/\n\t/* xswa.event_mask = ExposureMask; */\n\txswa.event_mask = 0xFFFFFF;\t/* all events */\n\tif (!(new_win = malloc(sizeof(*new_win))))\n\t\treturn ((void *)0);\n\tnew_win->window = XCreateWindow(xvar->display,xvar->root,0,0,size_x,size_y,\n\t\t\t\t\t0,CopyFromParent,InputOutput,xvar->visual,\n\t\t\t\t\tCWEventMask|CWBackPixel|CWBorderPixel|\n\t\t\t\t\tCWColormap,&xswa);\n\tmlx_int_anti_resize_win(xvar,new_win->window,size_x,size_y);\n\tXStoreName(xvar->display,new_win->window,title);\n\tXSetWMProtocols(xvar->display, new_win->window, &(xvar->wm_delete_window), 1);\n\txgcv.foreground = -1;\n\txgcv.function = GXcopy;\n\txgcv.plane_mask = AllPlanes;\n\tnew_win->gc = XCreateGC(xvar->display,new_win->window,\n\t\t\t\tGCFunction|GCPlaneMask|GCForeground,&xgcv);\n\tnew_win->next = xvar->win_list;\n\txvar->win_list = new_win;\n\t/*\n\tnew_win->mouse_hook = mlx_int_do_nothing;\n\tnew_win->key_hook = mlx_int_do_nothing;\n\tnew_win->expose_hook = mlx_int_do_nothing;\n\t*/\n\tbzero(&(new_win->hooks), sizeof(new_win->hooks));\n\tXMapRaised(xvar->display,new_win->window);\n\tmlx_int_wait_first_expose(xvar,new_win->window);\n\treturn (new_win);\n}\n",
  "minilibx-linux/mlx_pixel_put.c": "/*\n ** mlx_pixel_put.c for MiniLibX in \n ** \n ** Made by Charlie Root\n ** Login   <ol@epitech.net>\n ** \n ** Started on  Mon Jul 31 19:01:33 2000 Charlie Root\n** Last update Tue Sep 25 17:09:49 2001 Charlie Root\n */\n\n\n#include\t\"mlx_int.h\"\n\n\n\nint\t\tmlx_pixel_put(t_xvar *xvar,t_win_list *win,\n\t\t\t      int x,int y,int color)\n{\n   XGCValues\txgcv;\n   \n   xgcv.foreground = mlx_int_get_good_color(xvar,color);\n   XChangeGC(xvar->display,win->gc,GCForeground,&xgcv);\n   XDrawPoint(xvar->display,win->window,win->gc,x,y);\n   if (xvar->do_flush)\n     XFlush(xvar->display);\n}\n",
  "minilibx-linux/mlx_put_image_to_window.c": "/*\n** mlx_put_image_to_window.c for MiniLibX in raytraceur\n** \n** Made by Charlie Root\n** Login   <ol@epitech.net>\n** \n** Started on  Mon Aug 14 15:55:49 2000 Charlie Root\n** Last update Sun Oct  2 09:53:00 2005 Olivier Crouzet\n*/\n\n\n\n#include\t\"mlx_int.h\"\n\n\nint\tmlx_put_image_to_window(t_xvar *xvar,t_win_list *win,t_img *img,\n\t\t\t\tint x,int y)\n{\n  GC\tgc;\n\n  gc = win->gc;\n  if (img->gc)\n    {\n      gc = img->gc;\n      XSetClipOrigin(xvar->display, gc, x, y);\n    }\n  if (img->type==MLX_TYPE_SHM)\n    XShmPutImage(xvar->display,img->pix, win->gc, img->image,0,0,0,0,\n\t\t img->width,img->height,False);\n  if (img->type==MLX_TYPE_XIMAGE)\n    XPutImage(xvar->display,img->pix, win->gc, img->image,0,0,0,0,\n\t      img->width,img->height);\n  XCopyArea(xvar->display,img->pix,win->window, gc,\n\t    0,0,img->width,img->height,x,y);\n  if (xvar->do_flush)\n    XFlush(xvar->display);\n}\n",
  "minilibx-linux/mlx_rgb.c": "/*\n** This is a generated file with rgb2c.pl and rgb.txt from\n** the XFree86 distribution.\n*/\n\n#include\t\"mlx_int.h\"\n\nstruct s_col_name mlx_col_name[] =\n{\n { \"snow\" , 0xfffafa },\n { \"ghost white\" , 0xf8f8ff },\n { \"ghostwhite\" , 0xf8f8ff },\n { \"white smoke\" , 0xf5f5f5 },\n { \"whitesmoke\" , 0xf5f5f5 },\n { \"gainsboro\" , 0xdcdcdc },\n { \"floral white\" , 0xfffaf0 },\n { \"floralwhite\" , 0xfffaf0 },\n { \"old lace\" , 0xfdf5e6 },\n { \"oldlace\" , 0xfdf5e6 },\n { \"linen\" , 0xfaf0e6 },\n { \"antique white\" , 0xfaebd7 },\n { \"antiquewhite\" , 0xfaebd7 },\n { \"papaya whip\" , 0xffefd5 },\n { \"papayawhip\" , 0xffefd5 },\n { \"blanched almond\" , 0xffebcd },\n { \"blanchedalmond\" , 0xffebcd },\n { \"bisque\" , 0xffe4c4 },\n { \"peach puff\" , 0xffdab9 },\n { \"peachpuff\" , 0xffdab9 },\n { \"navajo white\" , 0xffdead },\n { \"navajowhite\" , 0xffdead },\n { \"moccasin\" , 0xffe4b5 },\n { \"cornsilk\" , 0xfff8dc },\n { \"ivory\" , 0xfffff0 },\n { \"lemon chiffon\" , 0xfffacd },\n { \"lemonchiffon\" , 0xfffacd },\n { \"seashell\" , 0xfff5ee },\n { \"honeydew\" , 0xf0fff0 },\n { \"mint cream\" , 0xf5fffa },\n { \"mintcream\" , 0xf5fffa },\n { \"azure\" , 0xf0ffff },\n { \"alice blue\" , 0xf0f8ff },\n { \"aliceblue\" , 0xf0f8ff },\n { \"lavender\" , 0xe6e6fa },\n { \"lavender blush\" , 0xfff0f5 },\n { \"lavenderblush\" , 0xfff0f5 },\n { \"misty rose\" , 0xffe4e1 },\n { \"mistyrose\" , 0xffe4e1 },\n { \"white\" , 0xffffff },\n { \"black\" , 0x0 },\n { \"dark slate\" , 0x2f4f4f },\n { \"darkslategray\" , 0x2f4f4f },\n { \"dark slate\" , 0x2f4f4f },\n { \"darkslategrey\" , 0x2f4f4f },\n { \"dim gray\" , 0x696969 },\n { \"dimgray\" , 0x696969 },\n { \"dim grey\" , 0x696969 },\n { \"dimgrey\" , 0x696969 },\n { \"slate gray\" , 0x708090 },\n { \"slategray\" , 0x708090 },\n { \"slate grey\" , 0x708090 },\n { \"slategrey\" , 0x708090 },\n { \"light slate\" , 0x778899 },\n { \"lightslategray\" , 0x778899 },\n { \"light slate\" , 0x778899 },\n { \"lightslategrey\" , 0x778899 },\n { \"gray\" , 0xbebebe },\n { \"grey\" , 0xbebebe },\n { \"light grey\" , 0xd3d3d3 },\n { \"lightgrey\" , 0xd3d3d3 },\n { \"light gray\" , 0xd3d3d3 },\n { \"lightgray\" , 0xd3d3d3 },\n { \"midnight blue\" , 0x191970 },\n { \"midnightblue\" , 0x191970 },\n { \"navy\" , 0x80 },\n { \"navy blue\" , 0x80 },\n { \"navyblue\" , 0x80 },\n { \"cornflower blue\" , 0x6495ed },\n { \"cornflowerblue\" , 0x6495ed },\n { \"dark slate\" , 0x483d8b },\n { \"darkslateblue\" , 0x483d8b },\n { \"slate blue\" , 0x6a5acd },\n { \"slateblue\" , 0x6a5acd },\n { \"medium slate\" , 0x7b68ee },\n { \"mediumslateblue\" , 0x7b68ee },\n { \"light slate\" , 0x8470ff },\n { \"lightslateblue\" , 0x8470ff },\n { \"medium blue\" , 0xcd },\n { \"mediumblue\" , 0xcd },\n { \"royal blue\" , 0x4169e1 },\n { \"royalblue\" , 0x4169e1 },\n { \"blue\" , 0xff },\n { \"dodger blue\" , 0x1e90ff },\n { \"dodgerblue\" , 0x1e90ff },\n { \"deep sky\" , 0xbfff },\n { \"deepskyblue\" , 0xbfff },\n { \"sky blue\" , 0x87ceeb },\n { \"skyblue\" , 0x87ceeb },\n { \"light sky\" , 0x87cefa },\n { \"lightskyblue\" , 0x87cefa },\n { \"steel blue\" , 0x4682b4 },\n { \"steelblue\" , 0x4682b4 },\n { \"light steel\" , 0xb0c4de },\n { \"lightsteelblue\" , 0xb0c4de },\n { \"light blue\" , 0xadd8e6 },\n { \"lightblue\" , 0xadd8e6 },\n { \"powder blue\" , 0xb0e0e6 },\n { \"powderblue\" , 0xb0e0e6 },\n { \"pale turquoise\" , 0xafeeee },\n { \"paleturquoise\" , 0xafeeee },\n { \"dark turquoise\" , 0xced1 },\n { \"darkturquoise\" , 0xced1 },\n { \"medium turquoise\" , 0x48d1cc },\n { \"mediumturquoise\" , 0x48d1cc },\n { \"turquoise\" , 0x40e0d0 },\n { \"cyan\" , 0xffff },\n { \"light cyan\" , 0xe0ffff },\n { \"lightcyan\" , 0xe0ffff },\n { \"cadet blue\" , 0x5f9ea0 },\n { \"cadetblue\" , 0x5f9ea0 },\n { \"medium aquamarine\" , 0x66cdaa },\n { \"mediumaquamarine\" , 0x66cdaa },\n { \"aquamarine\" , 0x7fffd4 },\n { \"dark green\" , 0x6400 },\n { \"darkgreen\" , 0x6400 },\n { \"dark olive\" , 0x556b2f },\n { \"darkolivegreen\" , 0x556b2f },\n { \"dark sea\" , 0x8fbc8f },\n { \"darkseagreen\" , 0x8fbc8f },\n { \"sea green\" , 0x2e8b57 },\n { \"seagreen\" , 0x2e8b57 },\n { \"medium sea\" , 0x3cb371 },\n { \"mediumseagreen\" , 0x3cb371 },\n { \"light sea\" , 0x20b2aa },\n { \"lightseagreen\" , 0x20b2aa },\n { \"pale green\" , 0x98fb98 },\n { \"palegreen\" , 0x98fb98 },\n { \"spring green\" , 0xff7f },\n { \"springgreen\" , 0xff7f },\n { \"lawn green\" , 0x7cfc00 },\n { \"lawngreen\" , 0x7cfc00 },\n { \"green\" , 0xff00 },\n { \"chartreuse\" , 0x7fff00 },\n { \"medium spring\" , 0xfa9a },\n { \"mediumspringgreen\" , 0xfa9a },\n { \"green yellow\" , 0xadff2f },\n { \"greenyellow\" , 0xadff2f },\n { \"lime green\" , 0x32cd32 },\n { \"limegreen\" , 0x32cd32 },\n { \"yellow green\" , 0x9acd32 },\n { \"yellowgreen\" , 0x9acd32 },\n { \"forest green\" , 0x228b22 },\n { \"forestgreen\" , 0x228b22 },\n { \"olive drab\" , 0x6b8e23 },\n { \"olivedrab\" , 0x6b8e23 },\n { \"dark khaki\" , 0xbdb76b },\n { \"darkkhaki\" , 0xbdb76b },\n { \"khaki\" , 0xf0e68c },\n { \"pale goldenrod\" , 0xeee8aa },\n { \"palegoldenrod\" , 0xeee8aa },\n { \"light goldenrod\" , 0xfafad2 },\n { \"lightgoldenrodyellow\" , 0xfafad2 },\n { \"light yellow\" , 0xffffe0 },\n { \"lightyellow\" , 0xffffe0 },\n { \"yellow\" , 0xffff00 },\n { \"gold\" , 0xffd700 },\n { \"light goldenrod\" , 0xeedd82 },\n { \"lightgoldenrod\" , 0xeedd82 },\n { \"goldenrod\" , 0xdaa520 },\n { \"dark goldenrod\" , 0xb8860b },\n { \"darkgoldenrod\" , 0xb8860b },\n { \"rosy brown\" , 0xbc8f8f },\n { \"rosybrown\" , 0xbc8f8f },\n { \"indian red\" , 0xcd5c5c },\n { \"indianred\" , 0xcd5c5c },\n { \"saddle brown\" , 0x8b4513 },\n { \"saddlebrown\" , 0x8b4513 },\n { \"sienna\" , 0xa0522d },\n { \"peru\" , 0xcd853f },\n { \"burlywood\" , 0xdeb887 },\n { \"beige\" , 0xf5f5dc },\n { \"wheat\" , 0xf5deb3 },\n { \"sandy brown\" , 0xf4a460 },\n { \"sandybrown\" , 0xf4a460 },\n { \"tan\" , 0xd2b48c },\n { \"chocolate\" , 0xd2691e },\n { \"firebrick\" , 0xb22222 },\n { \"brown\" , 0xa52a2a },\n { \"dark salmon\" , 0xe9967a },\n { \"darksalmon\" , 0xe9967a },\n { \"salmon\" , 0xfa8072 },\n { \"light salmon\" , 0xffa07a },\n { \"lightsalmon\" , 0xffa07a },\n { \"orange\" , 0xffa500 },\n { \"dark orange\" , 0xff8c00 },\n { \"darkorange\" , 0xff8c00 },\n { \"coral\" , 0xff7f50 },\n { \"light coral\" , 0xf08080 },\n { \"lightcoral\" , 0xf08080 },\n { \"tomato\" , 0xff6347 },\n { \"orange red\" , 0xff4500 },\n { \"orangered\" , 0xff4500 },\n { \"red\" , 0xff0000 },\n { \"hot pink\" , 0xff69b4 },\n { \"hotpink\" , 0xff69b4 },\n { \"deep pink\" , 0xff1493 },\n { \"deeppink\" , 0xff1493 },\n { \"pink\" , 0xffc0cb },\n { \"light pink\" , 0xffb6c1 },\n { \"lightpink\" , 0xffb6c1 },\n { \"pale violet\" , 0xdb7093 },\n { \"palevioletred\" , 0xdb7093 },\n { \"maroon\" , 0xb03060 },\n { \"medium violet\" , 0xc71585 },\n { \"mediumvioletred\" , 0xc71585 },\n { \"violet red\" , 0xd02090 },\n { \"violetred\" , 0xd02090 },\n { \"magenta\" , 0xff00ff },\n { \"violet\" , 0xee82ee },\n { \"plum\" , 0xdda0dd },\n { \"orchid\" , 0xda70d6 },\n { \"medium orchid\" , 0xba55d3 },\n { \"mediumorchid\" , 0xba55d3 },\n { \"dark orchid\" , 0x9932cc },\n { \"darkorchid\" , 0x9932cc },\n { \"dark violet\" , 0x9400d3 },\n { \"darkviolet\" , 0x9400d3 },\n { \"blue violet\" , 0x8a2be2 },\n { \"blueviolet\" , 0x8a2be2 },\n { \"purple\" , 0xa020f0 },\n { \"medium purple\" , 0x9370db },\n { \"mediumpurple\" , 0x9370db },\n { \"thistle\" , 0xd8bfd8 },\n { \"snow1\" , 0xfffafa },\n { \"snow2\" , 0xeee9e9 },\n { \"snow3\" , 0xcdc9c9 },\n { \"snow4\" , 0x8b8989 },\n { \"seashell1\" , 0xfff5ee },\n { \"seashell2\" , 0xeee5de },\n { \"seashell3\" , 0xcdc5bf },\n { \"seashell4\" , 0x8b8682 },\n { \"antiquewhite1\" , 0xffefdb },\n { \"antiquewhite2\" , 0xeedfcc },\n { \"antiquewhite3\" , 0xcdc0b0 },\n { \"antiquewhite4\" , 0x8b8378 },\n { \"bisque1\" , 0xffe4c4 },\n { \"bisque2\" , 0xeed5b7 },\n { \"bisque3\" , 0xcdb79e },\n { \"bisque4\" , 0x8b7d6b },\n { \"peachpuff1\" , 0xffdab9 },\n { \"peachpuff2\" , 0xeecbad },\n { \"peachpuff3\" , 0xcdaf95 },\n { \"peachpuff4\" , 0x8b7765 },\n { \"navajowhite1\" , 0xffdead },\n { \"navajowhite2\" , 0xeecfa1 },\n { \"navajowhite3\" , 0xcdb38b },\n { \"navajowhite4\" , 0x8b795e },\n { \"lemonchiffon1\" , 0xfffacd },\n { \"lemonchiffon2\" , 0xeee9bf },\n { \"lemonchiffon3\" , 0xcdc9a5 },\n { \"lemonchiffon4\" , 0x8b8970 },\n { \"cornsilk1\" , 0xfff8dc },\n { \"cornsilk2\" , 0xeee8cd },\n { \"cornsilk3\" , 0xcdc8b1 },\n { \"cornsilk4\" , 0x8b8878 },\n { \"ivory1\" , 0xfffff0 },\n { \"ivory2\" , 0xeeeee0 },\n { \"ivory3\" , 0xcdcdc1 },\n { \"ivory4\" , 0x8b8b83 },\n { \"honeydew1\" , 0xf0fff0 },\n { \"honeydew2\" , 0xe0eee0 },\n { \"honeydew3\" , 0xc1cdc1 },\n { \"honeydew4\" , 0x838b83 },\n { \"lavenderblush1\" , 0xfff0f5 },\n { \"lavenderblush2\" , 0xeee0e5 },\n { \"lavenderblush3\" , 0xcdc1c5 },\n { \"lavenderblush4\" , 0x8b8386 },\n { \"mistyrose1\" , 0xffe4e1 },\n { \"mistyrose2\" , 0xeed5d2 },\n { \"mistyrose3\" , 0xcdb7b5 },\n { \"mistyrose4\" , 0x8b7d7b },\n { \"azure1\" , 0xf0ffff },\n { \"azure2\" , 0xe0eeee },\n { \"azure3\" , 0xc1cdcd },\n { \"azure4\" , 0x838b8b },\n { \"slateblue1\" , 0x836fff },\n { \"slateblue2\" , 0x7a67ee },\n { \"slateblue3\" , 0x6959cd },\n { \"slateblue4\" , 0x473c8b },\n { \"royalblue1\" , 0x4876ff },\n { \"royalblue2\" , 0x436eee },\n { \"royalblue3\" , 0x3a5fcd },\n { \"royalblue4\" , 0x27408b },\n { \"blue1\" , 0xff },\n { \"blue2\" , 0xee },\n { \"blue3\" , 0xcd },\n { \"blue4\" , 0x8b },\n { \"dodgerblue1\" , 0x1e90ff },\n { \"dodgerblue2\" , 0x1c86ee },\n { \"dodgerblue3\" , 0x1874cd },\n { \"dodgerblue4\" , 0x104e8b },\n { \"steelblue1\" , 0x63b8ff },\n { \"steelblue2\" , 0x5cacee },\n { \"steelblue3\" , 0x4f94cd },\n { \"steelblue4\" , 0x36648b },\n { \"deepskyblue1\" , 0xbfff },\n { \"deepskyblue2\" , 0xb2ee },\n { \"deepskyblue3\" , 0x9acd },\n { \"deepskyblue4\" , 0x688b },\n { \"skyblue1\" , 0x87ceff },\n { \"skyblue2\" , 0x7ec0ee },\n { \"skyblue3\" , 0x6ca6cd },\n { \"skyblue4\" , 0x4a708b },\n { \"lightskyblue1\" , 0xb0e2ff },\n { \"lightskyblue2\" , 0xa4d3ee },\n { \"lightskyblue3\" , 0x8db6cd },\n { \"lightskyblue4\" , 0x607b8b },\n { \"slategray1\" , 0xc6e2ff },\n { \"slategray2\" , 0xb9d3ee },\n { \"slategray3\" , 0x9fb6cd },\n { \"slategray4\" , 0x6c7b8b },\n { \"lightsteelblue1\" , 0xcae1ff },\n { \"lightsteelblue2\" , 0xbcd2ee },\n { \"lightsteelblue3\" , 0xa2b5cd },\n { \"lightsteelblue4\" , 0x6e7b8b },\n { \"lightblue1\" , 0xbfefff },\n { \"lightblue2\" , 0xb2dfee },\n { \"lightblue3\" , 0x9ac0cd },\n { \"lightblue4\" , 0x68838b },\n { \"lightcyan1\" , 0xe0ffff },\n { \"lightcyan2\" , 0xd1eeee },\n { \"lightcyan3\" , 0xb4cdcd },\n { \"lightcyan4\" , 0x7a8b8b },\n { \"paleturquoise1\" , 0xbbffff },\n { \"paleturquoise2\" , 0xaeeeee },\n { \"paleturquoise3\" , 0x96cdcd },\n { \"paleturquoise4\" , 0x668b8b },\n { \"cadetblue1\" , 0x98f5ff },\n { \"cadetblue2\" , 0x8ee5ee },\n { \"cadetblue3\" , 0x7ac5cd },\n { \"cadetblue4\" , 0x53868b },\n { \"turquoise1\" , 0xf5ff },\n { \"turquoise2\" , 0xe5ee },\n { \"turquoise3\" , 0xc5cd },\n { \"turquoise4\" , 0x868b },\n { \"cyan1\" , 0xffff },\n { \"cyan2\" , 0xeeee },\n { \"cyan3\" , 0xcdcd },\n { \"cyan4\" , 0x8b8b },\n { \"darkslategray1\" , 0x97ffff },\n { \"darkslategray2\" , 0x8deeee },\n { \"darkslategray3\" , 0x79cdcd },\n { \"darkslategray4\" , 0x528b8b },\n { \"aquamarine1\" , 0x7fffd4 },\n { \"aquamarine2\" , 0x76eec6 },\n { \"aquamarine3\" , 0x66cdaa },\n { \"aquamarine4\" , 0x458b74 },\n { \"darkseagreen1\" , 0xc1ffc1 },\n { \"darkseagreen2\" , 0xb4eeb4 },\n { \"darkseagreen3\" , 0x9bcd9b },\n { \"darkseagreen4\" , 0x698b69 },\n { \"seagreen1\" , 0x54ff9f },\n { \"seagreen2\" , 0x4eee94 },\n { \"seagreen3\" , 0x43cd80 },\n { \"seagreen4\" , 0x2e8b57 },\n { \"palegreen1\" , 0x9aff9a },\n { \"palegreen2\" , 0x90ee90 },\n { \"palegreen3\" , 0x7ccd7c },\n { \"palegreen4\" , 0x548b54 },\n { \"springgreen1\" , 0xff7f },\n { \"springgreen2\" , 0xee76 },\n { \"springgreen3\" , 0xcd66 },\n { \"springgreen4\" , 0x8b45 },\n { \"green1\" , 0xff00 },\n { \"green2\" , 0xee00 },\n { \"green3\" , 0xcd00 },\n { \"green4\" , 0x8b00 },\n { \"chartreuse1\" , 0x7fff00 },\n { \"chartreuse2\" , 0x76ee00 },\n { \"chartreuse3\" , 0x66cd00 },\n { \"chartreuse4\" , 0x458b00 },\n { \"olivedrab1\" , 0xc0ff3e },\n { \"olivedrab2\" , 0xb3ee3a },\n { \"olivedrab3\" , 0x9acd32 },\n { \"olivedrab4\" , 0x698b22 },\n { \"darkolivegreen1\" , 0xcaff70 },\n { \"darkolivegreen2\" , 0xbcee68 },\n { \"darkolivegreen3\" , 0xa2cd5a },\n { \"darkolivegreen4\" , 0x6e8b3d },\n { \"khaki1\" , 0xfff68f },\n { \"khaki2\" , 0xeee685 },\n { \"khaki3\" , 0xcdc673 },\n { \"khaki4\" , 0x8b864e },\n { \"lightgoldenrod1\" , 0xffec8b },\n { \"lightgoldenrod2\" , 0xeedc82 },\n { \"lightgoldenrod3\" , 0xcdbe70 },\n { \"lightgoldenrod4\" , 0x8b814c },\n { \"lightyellow1\" , 0xffffe0 },\n { \"lightyellow2\" , 0xeeeed1 },\n { \"lightyellow3\" , 0xcdcdb4 },\n { \"lightyellow4\" , 0x8b8b7a },\n { \"yellow1\" , 0xffff00 },\n { \"yellow2\" , 0xeeee00 },\n { \"yellow3\" , 0xcdcd00 },\n { \"yellow4\" , 0x8b8b00 },\n { \"gold1\" , 0xffd700 },\n { \"gold2\" , 0xeec900 },\n { \"gold3\" , 0xcdad00 },\n { \"gold4\" , 0x8b7500 },\n { \"goldenrod1\" , 0xffc125 },\n { \"goldenrod2\" , 0xeeb422 },\n { \"goldenrod3\" , 0xcd9b1d },\n { \"goldenrod4\" , 0x8b6914 },\n { \"darkgoldenrod1\" , 0xffb90f },\n { \"darkgoldenrod2\" , 0xeead0e },\n { \"darkgoldenrod3\" , 0xcd950c },\n { \"darkgoldenrod4\" , 0x8b6508 },\n { \"rosybrown1\" , 0xffc1c1 },\n { \"rosybrown2\" , 0xeeb4b4 },\n { \"rosybrown3\" , 0xcd9b9b },\n { \"rosybrown4\" , 0x8b6969 },\n { \"indianred1\" , 0xff6a6a },\n { \"indianred2\" , 0xee6363 },\n { \"indianred3\" , 0xcd5555 },\n { \"indianred4\" , 0x8b3a3a },\n { \"sienna1\" , 0xff8247 },\n { \"sienna2\" , 0xee7942 },\n { \"sienna3\" , 0xcd6839 },\n { \"sienna4\" , 0x8b4726 },\n { \"burlywood1\" , 0xffd39b },\n { \"burlywood2\" , 0xeec591 },\n { \"burlywood3\" , 0xcdaa7d },\n { \"burlywood4\" , 0x8b7355 },\n { \"wheat1\" , 0xffe7ba },\n { \"wheat2\" , 0xeed8ae },\n { \"wheat3\" , 0xcdba96 },\n { \"wheat4\" , 0x8b7e66 },\n { \"tan1\" , 0xffa54f },\n { \"tan2\" , 0xee9a49 },\n { \"tan3\" , 0xcd853f },\n { \"tan4\" , 0x8b5a2b },\n { \"chocolate1\" , 0xff7f24 },\n { \"chocolate2\" , 0xee7621 },\n { \"chocolate3\" , 0xcd661d },\n { \"chocolate4\" , 0x8b4513 },\n { \"firebrick1\" , 0xff3030 },\n { \"firebrick2\" , 0xee2c2c },\n { \"firebrick3\" , 0xcd2626 },\n { \"firebrick4\" , 0x8b1a1a },\n { \"brown1\" , 0xff4040 },\n { \"brown2\" , 0xee3b3b },\n { \"brown3\" , 0xcd3333 },\n { \"brown4\" , 0x8b2323 },\n { \"salmon1\" , 0xff8c69 },\n { \"salmon2\" , 0xee8262 },\n { \"salmon3\" , 0xcd7054 },\n { \"salmon4\" , 0x8b4c39 },\n { \"lightsalmon1\" , 0xffa07a },\n { \"lightsalmon2\" , 0xee9572 },\n { \"lightsalmon3\" , 0xcd8162 },\n { \"lightsalmon4\" , 0x8b5742 },\n { \"orange1\" , 0xffa500 },\n { \"orange2\" , 0xee9a00 },\n { \"orange3\" , 0xcd8500 },\n { \"orange4\" , 0x8b5a00 },\n { \"darkorange1\" , 0xff7f00 },\n { \"darkorange2\" , 0xee7600 },\n { \"darkorange3\" , 0xcd6600 },\n { \"darkorange4\" , 0x8b4500 },\n { \"coral1\" , 0xff7256 },\n { \"coral2\" , 0xee6a50 },\n { \"coral3\" , 0xcd5b45 },\n { \"coral4\" , 0x8b3e2f },\n { \"tomato1\" , 0xff6347 },\n { \"tomato2\" , 0xee5c42 },\n { \"tomato3\" , 0xcd4f39 },\n { \"tomato4\" , 0x8b3626 },\n { \"orangered1\" , 0xff4500 },\n { \"orangered2\" , 0xee4000 },\n { \"orangered3\" , 0xcd3700 },\n { \"orangered4\" , 0x8b2500 },\n { \"red1\" , 0xff0000 },\n { \"red2\" , 0xee0000 },\n { \"red3\" , 0xcd0000 },\n { \"red4\" , 0x8b0000 },\n { \"deeppink1\" , 0xff1493 },\n { \"deeppink2\" , 0xee1289 },\n { \"deeppink3\" , 0xcd1076 },\n { \"deeppink4\" , 0x8b0a50 },\n { \"hotpink1\" , 0xff6eb4 },\n { \"hotpink2\" , 0xee6aa7 },\n { \"hotpink3\" , 0xcd6090 },\n { \"hotpink4\" , 0x8b3a62 },\n { \"pink1\" , 0xffb5c5 },\n { \"pink2\" , 0xeea9b8 },\n { \"pink3\" , 0xcd919e },\n { \"pink4\" , 0x8b636c },\n { \"lightpink1\" , 0xffaeb9 },\n { \"lightpink2\" , 0xeea2ad },\n { \"lightpink3\" , 0xcd8c95 },\n { \"lightpink4\" , 0x8b5f65 },\n { \"palevioletred1\" , 0xff82ab },\n { \"palevioletred2\" , 0xee799f },\n { \"palevioletred3\" , 0xcd6889 },\n { \"palevioletred4\" , 0x8b475d },\n { \"maroon1\" , 0xff34b3 },\n { \"maroon2\" , 0xee30a7 },\n { \"maroon3\" , 0xcd2990 },\n { \"maroon4\" , 0x8b1c62 },\n { \"violetred1\" , 0xff3e96 },\n { \"violetred2\" , 0xee3a8c },\n { \"violetred3\" , 0xcd3278 },\n { \"violetred4\" , 0x8b2252 },\n { \"magenta1\" , 0xff00ff },\n { \"magenta2\" , 0xee00ee },\n { \"magenta3\" , 0xcd00cd },\n { \"magenta4\" , 0x8b008b },\n { \"orchid1\" , 0xff83fa },\n { \"orchid2\" , 0xee7ae9 },\n { \"orchid3\" , 0xcd69c9 },\n { \"orchid4\" , 0x8b4789 },\n { \"plum1\" , 0xffbbff },\n { \"plum2\" , 0xeeaeee },\n { \"plum3\" , 0xcd96cd },\n { \"plum4\" , 0x8b668b },\n { \"mediumorchid1\" , 0xe066ff },\n { \"mediumorchid2\" , 0xd15fee },\n { \"mediumorchid3\" , 0xb452cd },\n { \"mediumorchid4\" , 0x7a378b },\n { \"darkorchid1\" , 0xbf3eff },\n { \"darkorchid2\" , 0xb23aee },\n { \"darkorchid3\" , 0x9a32cd },\n { \"darkorchid4\" , 0x68228b },\n { \"purple1\" , 0x9b30ff },\n { \"purple2\" , 0x912cee },\n { \"purple3\" , 0x7d26cd },\n { \"purple4\" , 0x551a8b },\n { \"mediumpurple1\" , 0xab82ff },\n { \"mediumpurple2\" , 0x9f79ee },\n { \"mediumpurple3\" , 0x8968cd },\n { \"mediumpurple4\" , 0x5d478b },\n { \"thistle1\" , 0xffe1ff },\n { \"thistle2\" , 0xeed2ee },\n { \"thistle3\" , 0xcdb5cd },\n { \"thistle4\" , 0x8b7b8b },\n { \"gray0\" , 0x0 },\n { \"grey0\" , 0x0 },\n { \"gray1\" , 0x30303 },\n { \"grey1\" , 0x30303 },\n { \"gray2\" , 0x50505 },\n { \"grey2\" , 0x50505 },\n { \"gray3\" , 0x80808 },\n { \"grey3\" , 0x80808 },\n { \"gray4\" , 0xa0a0a },\n { \"grey4\" , 0xa0a0a },\n { \"gray5\" , 0xd0d0d },\n { \"grey5\" , 0xd0d0d },\n { \"gray6\" , 0xf0f0f },\n { \"grey6\" , 0xf0f0f },\n { \"gray7\" , 0x121212 },\n { \"grey7\" , 0x121212 },\n { \"gray8\" , 0x141414 },\n { \"grey8\" , 0x141414 },\n { \"gray9\" , 0x171717 },\n { \"grey9\" , 0x171717 },\n { \"gray10\" , 0x1a1a1a },\n { \"grey10\" , 0x1a1a1a },\n { \"gray11\" , 0x1c1c1c },\n { \"grey11\" , 0x1c1c1c },\n { \"gray12\" , 0x1f1f1f },\n { \"grey12\" , 0x1f1f1f },\n { \"gray13\" , 0x212121 },\n { \"grey13\" , 0x212121 },\n { \"gray14\" , 0x242424 },\n { \"grey14\" , 0x242424 },\n { \"gray15\" , 0x262626 },\n { \"grey15\" , 0x262626 },\n { \"gray16\" , 0x292929 },\n { \"grey16\" , 0x292929 },\n { \"gray17\" , 0x2b2b2b },\n { \"grey17\" , 0x2b2b2b },\n { \"gray18\" , 0x2e2e2e },\n { \"grey18\" , 0x2e2e2e },\n { \"gray19\" , 0x303030 },\n { \"grey19\" , 0x303030 },\n { \"gray20\" , 0x333333 },\n { \"grey20\" , 0x333333 },\n { \"gray21\" , 0x363636 },\n { \"grey21\" , 0x363636 },\n { \"gray22\" , 0x383838 },\n { \"grey22\" , 0x383838 },\n { \"gray23\" , 0x3b3b3b },\n { \"grey23\" , 0x3b3b3b },\n { \"gray24\" , 0x3d3d3d },\n { \"grey24\" , 0x3d3d3d },\n { \"gray25\" , 0x404040 },\n { \"grey25\" , 0x404040 },\n { \"gray26\" , 0x424242 },\n { \"grey26\" , 0x424242 },\n { \"gray27\" , 0x454545 },\n { \"grey27\" , 0x454545 },\n { \"gray28\" , 0x474747 },\n { \"grey28\" , 0x474747 },\n { \"gray29\" , 0x4a4a4a },\n { \"grey29\" , 0x4a4a4a },\n { \"gray30\" , 0x4d4d4d },\n { \"grey30\" , 0x4d4d4d },\n { \"gray31\" , 0x4f4f4f },\n { \"grey31\" , 0x4f4f4f },\n { \"gray32\" , 0x525252 },\n { \"grey32\" , 0x525252 },\n { \"gray33\" , 0x545454 },\n { \"grey33\" , 0x545454 },\n { \"gray34\" , 0x575757 },\n { \"grey34\" , 0x575757 },\n { \"gray35\" , 0x595959 },\n { \"grey35\" , 0x595959 },\n { \"gray36\" , 0x5c5c5c },\n { \"grey36\" , 0x5c5c5c },\n { \"gray37\" , 0x5e5e5e },\n { \"grey37\" , 0x5e5e5e },\n { \"gray38\" , 0x616161 },\n { \"grey38\" , 0x616161 },\n { \"gray39\" , 0x636363 },\n { \"grey39\" , 0x636363 },\n { \"gray40\" , 0x666666 },\n { \"grey40\" , 0x666666 },\n { \"gray41\" , 0x696969 },\n { \"grey41\" , 0x696969 },\n { \"gray42\" , 0x6b6b6b },\n { \"grey42\" , 0x6b6b6b },\n { \"gray43\" , 0x6e6e6e },\n { \"grey43\" , 0x6e6e6e },\n { \"gray44\" , 0x707070 },\n { \"grey44\" , 0x707070 },\n { \"gray45\" , 0x737373 },\n { \"grey45\" , 0x737373 },\n { \"gray46\" , 0x757575 },\n { \"grey46\" , 0x757575 },\n { \"gray47\" , 0x787878 },\n { \"grey47\" , 0x787878 },\n { \"gray48\" , 0x7a7a7a },\n { \"grey48\" , 0x7a7a7a },\n { \"gray49\" , 0x7d7d7d },\n { \"grey49\" , 0x7d7d7d },\n { \"gray50\" , 0x7f7f7f },\n { \"grey50\" , 0x7f7f7f },\n { \"gray51\" , 0x828282 },\n { \"grey51\" , 0x828282 },\n { \"gray52\" , 0x858585 },\n { \"grey52\" , 0x858585 },\n { \"gray53\" , 0x878787 },\n { \"grey53\" , 0x878787 },\n { \"gray54\" , 0x8a8a8a },\n { \"grey54\" , 0x8a8a8a },\n { \"gray55\" , 0x8c8c8c },\n { \"grey55\" , 0x8c8c8c },\n { \"gray56\" , 0x8f8f8f },\n { \"grey56\" , 0x8f8f8f },\n { \"gray57\" , 0x919191 },\n { \"grey57\" , 0x919191 },\n { \"gray58\" , 0x949494 },\n { \"grey58\" , 0x949494 },\n { \"gray59\" , 0x969696 },\n { \"grey59\" , 0x969696 },\n { \"gray60\" , 0x999999 },\n { \"grey60\" , 0x999999 },\n { \"gray61\" , 0x9c9c9c },\n { \"grey61\" , 0x9c9c9c },\n { \"gray62\" , 0x9e9e9e },\n { \"grey62\" , 0x9e9e9e },\n { \"gray63\" , 0xa1a1a1 },\n { \"grey63\" , 0xa1a1a1 },\n { \"gray64\" , 0xa3a3a3 },\n { \"grey64\" , 0xa3a3a3 },\n { \"gray65\" , 0xa6a6a6 },\n { \"grey65\" , 0xa6a6a6 },\n { \"gray66\" , 0xa8a8a8 },\n { \"grey66\" , 0xa8a8a8 },\n { \"gray67\" , 0xababab },\n { \"grey67\" , 0xababab },\n { \"gray68\" , 0xadadad },\n { \"grey68\" , 0xadadad },\n { \"gray69\" , 0xb0b0b0 },\n { \"grey69\" , 0xb0b0b0 },\n { \"gray70\" , 0xb3b3b3 },\n { \"grey70\" , 0xb3b3b3 },\n { \"gray71\" , 0xb5b5b5 },\n { \"grey71\" , 0xb5b5b5 },\n { \"gray72\" , 0xb8b8b8 },\n { \"grey72\" , 0xb8b8b8 },\n { \"gray73\" , 0xbababa },\n { \"grey73\" , 0xbababa },\n { \"gray74\" , 0xbdbdbd },\n { \"grey74\" , 0xbdbdbd },\n { \"gray75\" , 0xbfbfbf },\n { \"grey75\" , 0xbfbfbf },\n { \"gray76\" , 0xc2c2c2 },\n { \"grey76\" , 0xc2c2c2 },\n { \"gray77\" , 0xc4c4c4 },\n { \"grey77\" , 0xc4c4c4 },\n { \"gray78\" , 0xc7c7c7 },\n { \"grey78\" , 0xc7c7c7 },\n { \"gray79\" , 0xc9c9c9 },\n { \"grey79\" , 0xc9c9c9 },\n { \"gray80\" , 0xcccccc },\n { \"grey80\" , 0xcccccc },\n { \"gray81\" , 0xcfcfcf },\n { \"grey81\" , 0xcfcfcf },\n { \"gray82\" , 0xd1d1d1 },\n { \"grey82\" , 0xd1d1d1 },\n { \"gray83\" , 0xd4d4d4 },\n { \"grey83\" , 0xd4d4d4 },\n { \"gray84\" , 0xd6d6d6 },\n { \"grey84\" , 0xd6d6d6 },\n { \"gray85\" , 0xd9d9d9 },\n { \"grey85\" , 0xd9d9d9 },\n { \"gray86\" , 0xdbdbdb },\n { \"grey86\" , 0xdbdbdb },\n { \"gray87\" , 0xdedede },\n { \"grey87\" , 0xdedede },\n { \"gray88\" , 0xe0e0e0 },\n { \"grey88\" , 0xe0e0e0 },\n { \"gray89\" , 0xe3e3e3 },\n { \"grey89\" , 0xe3e3e3 },\n { \"gray90\" , 0xe5e5e5 },\n { \"grey90\" , 0xe5e5e5 },\n { \"gray91\" , 0xe8e8e8 },\n { \"grey91\" , 0xe8e8e8 },\n { \"gray92\" , 0xebebeb },\n { \"grey92\" , 0xebebeb },\n { \"gray93\" , 0xededed },\n { \"grey93\" , 0xededed },\n { \"gray94\" , 0xf0f0f0 },\n { \"grey94\" , 0xf0f0f0 },\n { \"gray95\" , 0xf2f2f2 },\n { \"grey95\" , 0xf2f2f2 },\n { \"gray96\" , 0xf5f5f5 },\n { \"grey96\" , 0xf5f5f5 },\n { \"gray97\" , 0xf7f7f7 },\n { \"grey97\" , 0xf7f7f7 },\n { \"gray98\" , 0xfafafa },\n { \"grey98\" , 0xfafafa },\n { \"gray99\" , 0xfcfcfc },\n { \"grey99\" , 0xfcfcfc },\n { \"gray100\" , 0xffffff },\n { \"grey100\" , 0xffffff },\n { \"dark grey\" , 0xa9a9a9 },\n { \"darkgrey\" , 0xa9a9a9 },\n { \"dark gray\" , 0xa9a9a9 },\n { \"darkgray\" , 0xa9a9a9 },\n { \"dark blue\" , 0x8b },\n { \"darkblue\" , 0x8b },\n { \"dark cyan\" , 0x8b8b },\n { \"darkcyan\" , 0x8b8b },\n { \"dark magenta\" , 0x8b008b },\n { \"darkmagenta\" , 0x8b008b },\n { \"dark red\" , 0x8b0000 },\n { \"darkred\" , 0x8b0000 },\n { \"light green\" , 0x90ee90 },\n { \"lightgreen\" , 0x90ee90 },\n { \"none\", -1 },\n { 0, 0 }\n};\n",
  "minilibx-linux/mlx_screen_size.c": "#include\t\"mlx_int.h\"\n\nint\t\tmlx_get_screen_size(void *mlx_ptr, int *sizex, int *sizey)\n{\n\tXWindowAttributes\txwAttr;\n\tStatus\t\t\t\tret;\n\tt_xvar\t\t\t\t*xvar;\n\t\n\txvar = mlx_ptr;\n\tret = XGetWindowAttributes(xvar->display, xvar->root, &xwAttr);\n\t(*sizex) = xwAttr.width;\n\t(*sizey) = xwAttr.height;\n}\n",
  "minilibx-linux/mlx_set_font.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   mlx_set_font.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: amalliar <marvin@42.fr>                    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2020/09/30 13:30:47 by amalliar          #+#    #+#             */\n/*   Updated: 2020/09/30 17:08:36 by amalliar         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"mlx_int.h\"\n\n/*\n** Allows to specify the font that will be used by mlx_string_put.\n**\n** Note: only fixed-width bitmap fonts are supported by Xlib, refer to xfontsel\n** utility to get valid font names for this function.\n*/\n\nvoid\tmlx_set_font(t_xvar *xvar, t_win_list *win, char *name)\n{\n\tstatic Font\t\tfont = 0;\n\n\tif (font)\n\t\tXUnloadFont(xvar->display, font);\n\tfont = XLoadFont(xvar->display, name);\n\tXSetFont(xvar->display, win->gc, font);\n}\n",
  "minilibx-linux/mlx_string_put.c": "/*\n ** mlx_string_put.c for MiniLibX in \n ** \n ** Made by Charlie Root\n ** Login   <ol@epitech.net>\n ** \n ** Started on  Mon Jul 31 19:01:33 2000 Charlie Root\n** Last update Tue Sep 25 17:11:47 2001 Charlie Root\n */\n\n\n#include\t\"mlx_int.h\"\n\n\n\nint\t\tmlx_string_put(t_xvar *xvar,t_win_list *win,\n\t\t\t       int x,int y,int color,char *string)\n{\n   XGCValues\txgcv;\n   \n   xgcv.foreground = mlx_int_get_good_color(xvar,color);\n   XChangeGC(xvar->display,win->gc,GCForeground,&xgcv);\n   XDrawString(xvar->display,win->window,win->gc,x,y,string,strlen(string));\n   if (xvar->do_flush)\n     XFlush(xvar->display);\n}\n",
  "minilibx-linux/mlx_xpm.c": "/*\n ** xpm-read.c for MinilibX in \n ** \n ** Made by Charlie Root\n ** Login   <ol@epitech.net>\n ** \n ** Started on  Tue Dec 11 15:25:27 2001 olivier crouzet\n ** Last update Sat Oct  1 14:56:13 2005 Olivier Crouzet\n */\n\n\n#include\t\"mlx_int.h\"\n\nextern struct s_col_name mlx_col_name[];\n\n\n#define\tRETURN\t{ if (colors) free(colors); if (tab) free(tab); \\\n\t\ttab = (void *)0; if (colors_direct) free(colors_direct); \\\n\t\tif (img) {XDestroyImage(img->image); \\\n\t\t\t\tXFreePixmap(xvar->display,img->pix);free(img);} \\\n\t\treturn ((void *)0);}\n\n\n\n\nchar\t*mlx_int_get_line(char *ptr,int *pos,int size)\n{\n\tint\t\t\tpos2;\n\tint\t\t\tpos3;\n\tint\t\t\tpos4;\n\n\tif ((pos2 = mlx_int_str_str(ptr+*pos,\"\\\"\",size-*pos))==-1)\n\t\treturn ((char *)0);\n\tif ((pos3 = mlx_int_str_str(ptr+*pos+pos2+1,\"\\\"\",size-*pos-pos2-1))==-1)\n\t\treturn ((char *)0);\n\t*(ptr+*pos+pos2) = 0;\n\t*(ptr+*pos+pos2+1+pos3) = 0;\n\tpos4 = *pos+pos2+1;\n\t*pos += pos2+pos3+2;\n\treturn (ptr+pos4);\n}\n\n\nunsigned int\tstrlcpy_is_not_posix(char *dest, char *src, unsigned int size)\n{\n\tunsigned\tcount;\n\tunsigned\ti;\n\n\tcount = 0;\n\twhile (src[count] != '\\0')\n\t\t++count;\n\ti = 0;\n\twhile (src[i] != '\\0' && i < (size - 1))\n\t{\n\t\tdest[i] = src[i];\n\t\t++i;\n\t}\n\tdest[i] = '\\0';\n\treturn (count);\n}\n\nchar\t*mlx_int_static_line(char **xpm_data,int *pos,int size)\n{\n\tstatic char\t*copy = 0;\n\tstatic int\tlen = 0;\n\tint\t\t\tlen2;\n\tchar\t\t*str;\n\n\tstr = xpm_data[(*pos)++];\n\tif ((len2 = strlen(str))>len)\n\t{\n\t\t\tif (copy)\n\t\t\t\t\tfree(copy);\n\t\t\tif (!(copy = malloc(len2+1)))\n\t\t\t\t\treturn ((char *)0);\n\t\t\tlen = len2;\n\t}\n\tstrlcpy_is_not_posix(copy, str, len2);\n\t\n\treturn (copy);\n}\n\n\nint\tmlx_int_get_col_name(char *str,int size)\n{\n\tint\tresult;\n\n\tresult = 0;\n\twhile (size--)\n\t\tresult = (result<<8)+*(str++);\n\t\n\treturn (result);\n}\n\nint\tmlx_int_get_text_rgb(char *name, char *end)\n{\n\tint\t\t\ti;\n\tchar\t\tbuff[64];\n\n\tif (*name == '#')\n\t\t\treturn (strtol(name+1,0,16));\n\tif (end)\n\t{\n\t\t\tsnprintf(buff, 64, \"%s %s\", name, end);\n\t\t\tname = buff;\n\t}\n\ti = 0;\n\twhile (mlx_col_name[i].name)\n\t{\n\t\t\tif (!strcasecmp(mlx_col_name[i].name, name))\n\t\t\t\t\treturn (mlx_col_name[i].color);\n\t\t\ti ++;\n\t}\n\treturn (0);\n}\n\n\nint\tmlx_int_xpm_set_pixel(t_img *img, char *data, int opp, int col, int x)\n{\n\tint\tdec;\n\t\n\tdec = opp;\n  \twhile (dec--)\n    {\n    \tif (img->image->byte_order)\n\t\t\t*(data+x*opp+dec) = col&0xFF;\n      \telse\n\t\t\t*(data+x*opp+opp-dec-1) = col&0xFF;\n      \tcol >>= 8;\n    }\n}\n\n\nvoid\t*mlx_int_parse_xpm(t_xvar *xvar,void *info,int info_size,char *(*f)())\n{\n\t\tint\t\tpos;\n\t\tchar\t*line;\n\t\tchar\t**tab;\n\t\tchar\t*data;\n\t\tchar\t*clip_data;\n\t\tint\t\tnc;\n\t\tint\t\topp;\n\t\tint\t\tcpp;\n\t\tint\t\tcol;\n\t\tint\t\trgb_col;\n\t\tint\t\tcol_name;\n\t\tint\t\tmethod;\n\t\tint\t\tx;\n\t\tint\t\ti;\n\t\tint\t\tj;\n\t\tt_img\t*img;\n\t\tt_xpm_col\t*colors;\n\t\tint\t\t*colors_direct;\n\t\tint\t\twidth;\n\t\tint\t\theight;\n\t\tXImage\t*clip_img;\n\t\tXGCValues\txgcv;\n\t\tPixmap\tclip_pix;\n\n\t\tcolors = 0;\n\t\tcolors_direct = 0;\n\t\timg = 0;\n\t\ttab = 0;\n\t\tpos = 0;\n\t\tif (!(line = f(info,&pos,info_size)) ||\n\t\t\t\t\t\t!(tab = mlx_int_str_to_wordtab(line)) || !(width = atoi(tab[0])) ||\n\t\t\t\t\t\t!(height = atoi(tab[1])) || !(nc = atoi(tab[2])) ||\n\t\t\t\t\t\t!(cpp = atoi(tab[3])) )\n\t\t\t\tRETURN;\n\t\tfree(tab);\n\t\ttab = 0;\n\n\t\tmethod = 0;\n\t\tif (cpp<=2)\n\t\t{\n\t\t\t\tmethod = 1;\n\t\t\t\tif (!(colors_direct = malloc((cpp==2?65536:256)*sizeof(int))))\n\t\t\t\t\t\tRETURN;\n\t\t}\n\t\telse\n\t\t\t\tif (!(colors = malloc(nc*sizeof(*colors))))\n\t\t\t\t\t\tRETURN;\n\n\t\tclip_data = 0;\n\n\t\ti = nc;\n\t\twhile (i--)\n\t\t{\n\t\t\t\tif (!(line = f(info,&pos,info_size)) ||\n\t\t\t\t\t\t\t\t!(tab = mlx_int_str_to_wordtab(line+cpp)) )\n\t\t\t\t\t\tRETURN;\n\t\t\t\tj = 0;\n\t\t\t\twhile (tab[j] && strcmp(tab[j++],\"c\"));\n\n\t\t\t\tif (!tab[j])\n\t\t\t\t\t\tRETURN;\n\t\t\t\trgb_col = mlx_int_get_text_rgb(tab[j], tab[j+1]);\n\t\t\t\t/*\n\t\t\t\tif ((rgb_col = mlx_int_get_text_rgb(tab[j], tab[j+1]))==-1)\n\t\t\t\t{\n\t\t\t\t\t\tif (!(clip_data = malloc(4*width*height)) ||   ok, nice size ..\n\t\t\t\t\t\t\t\t\t\t!(clip_img = XCreateImage(xvar->display, xvar->visual,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t1, XYPixmap, 0, clip_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth, height, 8, (width+7)/8)) )\n\t\t\t\t\t\t\t\tRETURN;\n\t\t\t\t\t\tmemset(clip_data, 0xFF, 4*width*height);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tif (method)\n\t\t\t\t\t\tcolors_direct[mlx_int_get_col_name(line,cpp)] = rgb_col;\n\t\t\t\t\t\t\t\t// rgb_col>=0?mlx_get_color_value(xvar, rgb_col):rgb_col;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t\tcolors[i].name = mlx_int_get_col_name(line,cpp);\n\t\t\t\t\t\tcolors[i].col = rgb_col; //rgb_col>=0?mlx_get_color_value(xvar,rgb_col):rgb_col;\n\t\t\t\t}\n\t\t\t\tfree(tab);\n\t\t\t\ttab = (void *)0;\n\t\t}\n\n\t\tif (!(img = mlx_new_image(xvar,width,height)))\n\t\t\t\tRETURN;\n\t\topp = img->bpp/8;\n\n\n\t\ti = height;\n\t\tdata = img->data;\n\t\twhile (i--)\n\t\t{\n\t\t\t\tif (!(line = f(info,&pos,info_size)))\n\t\t\t\t\t\tRETURN;\n\t\t\t\tx = 0;\n\t\t\t\twhile (x<width)\n\t\t\t\t{\n\t\t\t\t\t\tcol = 0;\n\t\t\t\t\t\tcol_name = mlx_int_get_col_name(line+cpp*x,cpp);\n\t\t\t\t\t\tif (method)\n\t\t\t\t\t\t\t\tcol = colors_direct[col_name];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tj = nc;\n\t\t\t\t\t\t\t\twhile (j--)\n\t\t\t\t\t\t\t\t\t\tif (colors[j].name==col_name)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tcol = colors[j].col;\n\t\t\t\t\t\t\t\t\t\t\t\tj = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tif (col==-1)\n\t\t\t\t\t\t\t\tXPutPixel(clip_img, x, height-1-i, 0);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tmlx_int_xpm_set_pixel(img, data, opp, col, x);\n\t\t\t\t\t\tx ++;\n\t\t\t\t\t\t*/\n\t\t\t\t\t\tif (col==-1)\n\t\t\t\t\t\t\tcol = 0xFF000000;\n\t\t\t\t\t\tmlx_int_xpm_set_pixel(img, data, opp, col, x);\n\t\t\t\t\t\t++x;\n\t\t\t\t}\n\t\t\t\tdata += img->size_line;\n\t\t}\n\t\t/*\n\t\tif (clip_data)\n\t\t{\n\t\t\t\tif (!(clip_pix = XCreatePixmap(xvar->display, xvar->root,\n\t\t\t\t\t\t\t\t\t\t\t\twidth, height, 1)) )\n\t\t\t\t\t\tRETURN;\n\t\t\t\timg->gc = XCreateGC(xvar->display, clip_pix, 0, &xgcv);\n\t\t\t\tXPutImage(xvar->display, clip_pix, img->gc, clip_img,\n\t\t\t\t\t\t\t\t0, 0, 0, 0, width, height);\n\t\t\t\tXFreeGC(xvar->display, img->gc);\n\t\t\t\txgcv.clip_mask = clip_pix;\n\t\t\t\txgcv.function = GXcopy;\n\t\t\t\txgcv.plane_mask = AllPlanes;\n\t\t\t\timg->gc = XCreateGC(xvar->display, xvar->root, GCClipMask|GCFunction|\n\t\t\t\t\t\t\t\tGCPlaneMask, &xgcv);\n\t\t\t\tXSync(xvar->display, False);\n\t\t\t\tXDestroyImage(clip_img);\n\t\t}\n\t\t*/\n\t\tif (colors)\n\t\t\t\tfree(colors);\n\t\tif (colors_direct)\n\t\t\t\tfree(colors_direct);\n\t\treturn (img);\n}\n\n\nint\tmlx_int_file_get_rid_comment(char *ptr, int size)\n{\n\t\tint\tcom_begin;\n\t\tint\tcom_end;\n\n\t\twhile ((com_begin = mlx_int_str_str_cote(ptr,\"/*\",size))!=-1)\n\t\t{\n\t\t\t\tcom_end = mlx_int_str_str(ptr+com_begin+2,\"*/\",size-com_begin-2);\n\t\t\t\tmemset(ptr+com_begin,' ',com_end+4);\n\t\t}\n\t\twhile ((com_begin = mlx_int_str_str_cote(ptr,\"//\",size))!=-1)\n\t\t{\n\t\t\t\tcom_end = mlx_int_str_str(ptr+com_begin+2,\"\\n\",size-com_begin-2);\n\t\t\t\tmemset(ptr+com_begin,' ',com_end+3);\n\t\t}\n}\n\n\nvoid\t*mlx_xpm_file_to_image(t_xvar *xvar,char *file,int *width,int *height)\n{\n\t\tint\tfd;\n\t\tint\tsize;\n\t\tchar\t*ptr;\n\t\tt_img\t*img;\n\n\t\tfd = -1;\n\t\tif ((fd = open(file,O_RDONLY))==-1 || (size = lseek(fd,0,SEEK_END))==-1 ||\n\t\t\t\t\t\t(ptr = mmap(0,size,PROT_WRITE|PROT_READ,MAP_PRIVATE,fd,0))==\n\t\t\t\t\t\t(void *)MAP_FAILED)\n\t\t{\n\t\t\t\tif (fd>=0)\n\t\t\t\t\t\tclose(fd);\n\t\t\t\treturn ((void *)0);\n\t\t}\n\t\tmlx_int_file_get_rid_comment(ptr, size);\n\t\tif (img = mlx_int_parse_xpm(xvar,ptr,size,mlx_int_get_line))\n\t\t{\n\t\t\t\t*width = img->width;\n\t\t\t\t*height = img->height;\n\t\t}\n\t\tmunmap(ptr,size);\n\t\tclose(fd);\n\t\treturn (img);\n}\n\nvoid\t*mlx_xpm_to_image(t_xvar *xvar,char **xpm_data,int *width,int *height)\n{\n\t\tt_img\t*img;\n\n\t\tif (img = mlx_int_parse_xpm(xvar,xpm_data,0,mlx_int_static_line))\n\t\t{\n\t\t\t\t*width = img->width;\n\t\t\t\t*height = img->height;\n\t\t}\n\t\treturn (img);\n}\n",
  "minilibx-linux/test/main.c": "\n#include\t\"mlx.h\"\n#include\t\"mlx_int.h\"\n\n#define\tWIN1_SX\t\t242\n#define\tWIN1_SY\t\t242\n#define\tIM1_SX\t\t42\n#define\tIM1_SY\t\t42\n#define\tIM3_SX\t\t242\n#define\tIM3_SY\t\t242\n\nvoid\t*mlx;\nvoid\t*win1;\nvoid    *win2;\nvoid    *win3;\nvoid    *im1;\nvoid\t*im2;\nvoid\t*im3;\nvoid\t*im4;\nint\tbpp1;\nint\tbpp2;\nint\tbpp3;\nint\tbpp4;\nint\tsl1;\nint\tsl2;\nint\tsl3;\nint\tsl4;\nint\tendian1;\nint\tendian2;\nint\tendian3;\nint\tendian4;\nchar\t*data1;\nchar\t*data2;\nchar\t*data3;\nchar\t*data4;\nint\txpm1_x;\nint\txpm1_y;\n\nint\tlocal_endian;\n\nint\tcolor_map_1(void *win,int w,int h);\nint\tcolor_map_2(unsigned char *data,int bpp,int sl,int w,int h,int endian, int type);\n\nint\texpose_win1(void *p)\n{\n  mlx_put_image_to_window(mlx,win1,im3,0,0);\n}\n\nint\texpose_win2(void *p)\n{\n  mlx_put_image_to_window(mlx,win2,im4,0,0);\n  mlx_put_image_to_window(mlx,win2,im2,0,0);\n}\n\nint\tkey_win1(int key,void *p)\n{\n  printf(\"Key in Win1 : %d\\n\",key);\n  if (key==0xFF1B)\n    exit(0);\n}\n\nint\tkey_win2(int key,void *p)\n{\n  printf(\"Key in Win2 : %d\\n\",key);\n  if (key==0xFF1B)\n    exit(0);\n}\n\nint\tkey_win3(int key,void *p)\n{\n  printf(\"Key in Win3 : %d\\n\",key);\n  if (key==0xFF1B)\n    mlx_destroy_window(mlx,win3);\n}\n\nint\tmouse_win1(int button,int x,int y, void *p)\n{\n  printf(\"Mouse in Win1, button %d at %dx%d.\\n\",button,x,y);\n}\n\nint\tmouse_win2(int button,int x,int y, void *p)\n{\n  printf(\"Mouse in Win2, button %d at %dx%d.\\n\",button,x,y);\n}\n\nint\tmouse_win3(int x,int y, void *p)\n{\n  printf(\"Mouse moving in Win3, at %dx%d.\\n\",x,y);\n}\n\n\nint\tmain()\n{\n  int\ta;\n\n  printf(\"MinilibX Test Program\\n\");\n  a = 0x11223344;\n  if (((unsigned char *)&a)[0] == 0x11)\n    local_endian = 1;\n  else\n    local_endian = 0;\n  printf(\" => Local Endian : %d\\n\",local_endian);\n\n  printf(\" => Connection ...\");\n  if (!(mlx = mlx_init()))\n    {\n      printf(\" !! KO !!\\n\");\n      exit(1);\n    }\n  printf(\"OK (use_xshm %d pshm_format %d)\\n\",((t_xvar *)mlx)->use_xshm,((t_xvar *)mlx)->pshm_format);\n\n  printf(\" => Window1 %dx%d \\\"Title 1\\\" ...\",WIN1_SX,WIN1_SY);\n  if (!(win1 = mlx_new_window(mlx,WIN1_SX,WIN1_SY,\"Title1\")))\n    {\n      printf(\" !! KO !!\\n\");\n      exit(1);\n    }\n  printf(\"OK\\n\");\n\n  printf(\" => Colormap sans event ...\");\n  color_map_1(win1,WIN1_SX,WIN1_SY);\n  printf(\"OK\\n\");\n  sleep(2);\n\n  printf(\" => Clear Window ...\");\n  mlx_clear_window(mlx,win1);\n  printf(\"OK\\n\");\n  sleep(2);\n\n  printf(\" => Image1 ZPixmap %dx%d ...\",IM1_SX,IM1_SY);\n  if (!(im1 = mlx_new_image(mlx,IM1_SX,IM1_SY)))\n    {\n      printf(\" !! KO !!\\n\");\n      exit(1);\n    }\n  data1 = mlx_get_data_addr(im1,&bpp1,&sl1,&endian1);\n  printf(\"OK (bpp1: %d, sizeline1: %d endian: %d type: %d)\\n\",bpp1,sl1,endian1,\n\t ((t_img *)im1)->type);\n\n  printf(\" => Fill Image1 ...\");\n  color_map_2(data1,bpp1,sl1,IM1_SX,IM1_SY,endian1, 1);\n  printf(\"OK (pixmap : %d)\\n\",(int)((t_img *)im1)->pix);\n\n  printf(\" => Put Image1 ...\");\n  mlx_put_image_to_window(mlx,win1,im1,20,20);\n  printf(\"OK\\n\");\n  sleep(2);\n\n  printf(\" => Destroy Image1 ... \");\n  mlx_destroy_image(mlx, im1);\n  printf(\"OK\\n\");\n  sleep(2);\n\n  printf(\" => Image3 ZPixmap %dx%d ...\",IM3_SX,IM3_SY);\n  if (!(im3 = mlx_new_image(mlx,IM3_SX,IM3_SY)))\n    {\n      printf(\" !! KO !!\\n\");\n      exit(1);\n    }\n  data3 = mlx_get_data_addr(im3,&bpp3,&sl3,&endian3);\n  printf(\"OK (bpp3 %d, sizeline3 %d endian3 %d type %d)\\n\",bpp3,sl3,endian3,\n\t ((t_img *)im3)->type);\n\n  printf(\" => Fill Image3 ...\");\n  color_map_2(data3,bpp3,sl3,IM3_SX,IM3_SY,endian3, 1);\n  printf(\"OK (pixmap : %d)\\n\",(int)((t_img *)im3)->pix);\n\n  printf(\" => Put Image3 ...\");\n  mlx_put_image_to_window(mlx,win1,im3,20,20);\n  printf(\"OK\\n\");\n  sleep(2);\n\n  printf(\" => String ...\");\n  mlx_string_put(mlx,win1,5,WIN1_SY/2,0xFF99FF,\"String output\");\n  mlx_string_put(mlx,win1,15,WIN1_SY/2+20,0x00FFFF,\"MinilibX test\");\n  printf(\"OK\\n\");\n  sleep(2);\n\n  printf(\" => Xpm from file ...\");\n  if (!(im2 = mlx_xpm_file_to_image(mlx,\"open.xpm\",&xpm1_x,&xpm1_y)))\n    {\n      printf(\" !! KO !!\\n\");\n      exit(1);\n    }\n  data2 = mlx_get_data_addr(im2,&bpp2,&sl2,&endian2);\n  printf(\"OK (xpm %dx%d)(img bpp2: %d, sizeline2: %d endian: %d type: %d)\\n\",\n\t xpm1_x,xpm1_y,bpp2,sl2,endian2,((t_img *)im2)->type);\n  sleep(2);\n\n  printf(\" => Put xpm ...\");\n  mlx_put_image_to_window(mlx,win1,im2,0,0);\n  mlx_put_image_to_window(mlx,win1,im2,100,100);\n  printf(\"OK\\n\");\n  sleep(2);\n\n  printf(\" => 2nd window,\");\n  win2 = mlx_new_window(mlx,WIN1_SX,WIN1_SY,\"Title2\");\n  if (!(im4 = mlx_new_image(mlx,IM3_SX, IM3_SY)))\n    {\n      printf(\" !! KO !!\\n\");\n      exit(1);\n    }\n  data4 = mlx_get_data_addr(im4,&bpp4,&sl4,&endian4);\n  color_map_2(data4,bpp4,sl4,IM3_SX,IM3_SY,endian4, 2);\n\n  printf(\" 3rd window, Installing hooks ...\");\n  win3 = mlx_new_window(mlx,WIN1_SX,WIN1_SY,\"Title3\");\n  mlx_expose_hook(win1,expose_win1,0);\n  mlx_mouse_hook(win1,mouse_win1,0);\n  mlx_key_hook(win1,key_win1,0);\n  mlx_expose_hook(win2,expose_win2,0);\n  mlx_mouse_hook(win2,mouse_win2,0);\n  mlx_key_hook(win2,key_win2,0);\n  mlx_key_hook(win3,key_win3,0);\n\n  mlx_hook(win3, MotionNotify, PointerMotionMask, mouse_win3, 0);\n\n  printf(\"OK\\nNow in Loop. Just play. Esc in 3 to destroy, 1&2 to quit.\\n\");\n  \n  mlx_loop(mlx);\n}\n\n\nint\tcolor_map_1(void *win,int w,int h)\n{\n  int\tx;\n  int\ty;\n  int\tcolor;\n\n  x = w;\n  while (x--)\n    {\n      y = h;\n      while (y--)\n        {\n          color = (x*255)/w+((((w-x)*255)/w)<<16)+(((y*255)/h)<<8);\n\t  mlx_pixel_put(mlx,win,x,y,color);\n        }\n    }\n}\n\n\nint\tcolor_map_2(unsigned char *data,int bpp,int sl,int w,int h,int endian, int type)\n{\n  int\tx;\n  int\ty;\n  int\topp;\n  int\tdec;\n  int\tcolor;\n  int\tcolor2;\n  unsigned char *ptr;\n\n  opp = bpp/8;\n  printf(\"(opp : %d) \",opp);\n  y = h;\n  while (y--)\n    {\n      ptr = data+y*sl;\n      x = w;\n      while (x--)\n        {\n\t  if (type==2)\n\t    color = (y*255)/w+((((w-x)*255)/w)<<16)\n\t      +(((y*255)/h)<<8);\n\t  else\n\t    color = (x*255)/w+((((w-x)*255)/w)<<16)+(((y*255)/h)<<8);\n          color2 = mlx_get_color_value(mlx,color);\n\t  dec = opp;\n\t  while (dec--)\n\t    if (endian==local_endian)\n\t      {\n\t\tif (endian)\n\t\t  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[4-opp+dec];\n\t\telse\n\t\t  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[dec];\n\t      }\n\t    else\n\t      {\n\t\tif (endian)\n\t\t  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[opp-1-dec];\n\t\telse\n\t\t  *(ptr+x*opp+dec) = ((unsigned char *)(&color2))[3-dec];\n\t      }\n        }\n    }\n\n}\n",
  "minilibx-linux/test/new_win.c": "\n\n\n#include \"mlx.h\"\n\n\nvoid *mlx;\nvoid *win1;\nvoid *win2;\n\n\n\nint gere_mouse(int x,int y,int button,void*toto)\n{\n  printf(\"Mouse event - new win\\n\");\n  mlx_destroy_window(mlx,win1);\n  win1 = mlx_new_window(mlx,random()%500,random()%500,\"new win\");\n  mlx_mouse_hook(win1,gere_mouse,0);\n}\n\n\nint main()\n{\n  srandom(time(0));\n  mlx = mlx_init();\n  win1 = mlx_new_window(mlx,300,300,\"win1\");\n  win2 = mlx_new_window(mlx,600,600,\"win2\");\n  mlx_mouse_hook(win1,gere_mouse,0);\n  mlx_mouse_hook(win2,gere_mouse,0);\n  mlx_loop(mlx);\n}\n",
  "tools/get_next_line.c": "#include \"cub3d.h\"\n\nstatic char\t*get_line(char *reserve)\n{\n\tint\t\tstart;\n\tchar\t*line;\n\tint\t\ti;\n\n\tstart = 0;\n\ti = 0;\n\twhile (reserve[i] != '\\n' && reserve[i] != '\\0')\n\t\ti++;\n\tline = ft_substr(reserve, start, i);\n\treturn (line);\n}\n\nstatic char\t*update_reserve(char *reserve)\n{\n\tchar\t*new_res;\n\tint\t\ti;\n\n\ti = 0;\n\twhile (reserve[i] != '\\n' && reserve[i] != '\\0')\n\t\ti++;\n\tif (reserve[i] == '\\n')\n\t\ti++;\n\tnew_res = gc_substr(reserve, i, ft_strlen(reserve) - i);\n\tfree(reserve);\n\treserve = NULL;\n\treturn (new_res);\n}\n\nstatic char\t*helper_func(char *buffer, char *reserve, int fd)\n{\n\tint\tbytes_read;\n\n\tbytes_read = 1;\n\twhile (bytes_read)\n\t{\n\t\tbytes_read = read(fd, buffer, BUFFER_SIZE);\n\t\tif (bytes_read == -1)\n\t\t\treturn (free(buffer), free(reserve), reserve = NULL, NULL);\n\t\tbuffer[bytes_read] = '\\0';\n\t\treserve = gc_strjoin(reserve, buffer);\n\t\tif (!reserve)\n\t\t\treturn (NULL);\n\t\tif (ft_strchr(reserve, '\\n'))\n\t\t\tbreak ;\n\t}\n\tfree(buffer);\n\treturn (reserve);\n}\n\nchar\t*get_next_line(int fd)\n{\n\tstatic char\t*reserve = NULL;\n\tchar\t\t*buffer;\n\tchar\t\t*line;\n\n\tif (fd < 0 || BUFFER_SIZE <= 0 || BUFFER_SIZE > INT_MAX)\n\t\treturn (free(reserve), reserve = NULL, NULL);\n\tbuffer = malloc((size_t) BUFFER_SIZE + 1);\n\tif (!buffer)\n\t\treturn (NULL);\n\treserve = helper_func(buffer, reserve, fd);\n\tif (!reserve || *reserve == '\\0')\n\t\treturn ( reserve = NULL, NULL);\n\tline = get_line(reserve);\n\treserve = update_reserve(reserve);\n\treturn (line);\n}\n\n",
  "tools/garbage_collector/gc_mall.c": "#include \"cub3d.h\"\n\nstatic t_gc_node\t**get_gc_head_instance(void)\n{\n\tstatic t_gc_node\t*head;\n\n\treturn (&head);\n}\n\nvoid\tgc_add_pt(void *pt)\n{\n\tt_gc_node\t*new_node;\n\tt_gc_node\t**head;\n\n\tif (!pt)\n\t\treturn ;\n\thead = get_gc_head_instance();\n\tnew_node = (t_gc_node *)malloc(sizeof(t_gc_node));\n\tif (!new_node)\n\t{\n\t\tperror(\"malloc failed in garbage collector\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tnew_node->pt = pt;\n\tnew_node->next = *head;\n\t*head = new_node;\n}\n\nchar\t*gc_strdup(char *str)\n{\n\tchar\t*new_str;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = ft_strdup(str);\n\tif (!new_str)\n\t{\n\t\tperror(\"strdup failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nchar\t*gc_substr(char const *s, unsigned int start, size_t len)\n{\n\tchar\t*new_str;\n\n\tif (!s)\n\t\treturn (NULL);\n\tnew_str = ft_substr(s, start, len);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\tgc_freed(void)\n{\n\tt_gc_node\t*current;\n\tt_gc_node\t*tmp;\n\tt_gc_node\t**head;\n\n\thead = get_gc_head_instance();\n\tcurrent = *head;\n\twhile (current != NULL)\n\t{\n\t\ttmp = current;\n\t\tcurrent = current->next;\n\t\tfree(tmp->pt);\n\t\tfree(tmp);\n\t}\n\t*head = NULL;\n}\n",
  "tools/garbage_collector/gc_mall2.c": "#include \"cub3d.h\"\n\n\n\nvoid\t*gc_mall(size_t size)\n{\n\tvoid\t*pt;\n\n\tpt = malloc(size);\n\tif (!pt)\n\t{\n\t\tperror(\"malloc failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(pt);\n\treturn (pt);\n}\n\nchar\t*gc_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\n\tnew_str = ft_strjoin(s1, s2);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\nchar\t**gc_split(char const *s, char c)\n{\n\tchar\t**new_arr;\n\tint\t\ti;\n\n\tif (!s)\n\t\treturn (NULL);\n\tnew_arr = ft_split(s, c);\n\tif (!new_arr)\n\t{\n\t\tperror(\"split failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// First, add the main array pointer to the garbage collector\n\tgc_add_pt(new_arr);\n\n\t// Now, crucially, add each string pointer from the array to the collector\n\ti = 0;\n\twhile (new_arr[i])\n\t{\n\t\tgc_add_pt(new_arr[i]);\n\t\ti++;\n\t}\n\treturn (new_arr);\n}",
  "tools/strings/strings1.c": "#include \"cub3d.h\"\n\nstatic size_t\tcount_words(char const *s, char c)\n{\n\tsize_t\tcount;\n\tsize_t\ti;\n\n\tcount = 0;\n\ti = 0;\n\twhile (s && s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tcount++;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\treturn (count);\n}\n\nstatic void\tpopulate_split(char **arr, char const *s, char c)\n{\n\tsize_t\ti;\n\tsize_t\tj;\n\tsize_t\tstart;\n\n\ti = 0;\n\tj = 0;\n\twhile (s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tstart = i;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t\tarr[j++] = ft_substr(s, start, i - start);\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[j] = NULL;\n}\n\nchar\t**ft_split(char const *s, char c)\n{\n\tchar\t**arr;\n\tsize_t\twords;\n\n\tif (!s)\n\t\treturn (NULL);\n\twords = count_words(s, c);\n\tarr = (char **)malloc(sizeof(char *) * (words + 1));\n\tif (!arr)\n\t\treturn (NULL);\n\tpopulate_split(arr, s, c);\n\treturn (arr);\n}\n\nchar\t*ft_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\tsize_t\ti;\n\tsize_t\tj;\n    size_t  len1;\n    size_t  len2;\n\n\tif (!s2) \n\t\treturn (NULL);\n    len1 = (s1 == NULL) ? 0 : ft_strlen(s1);\n    len2 = ft_strlen(s2);\n\n\tnew_str = (char *)malloc(len1 + len2 + 1);\n\tif (!new_str)\n\t\treturn (NULL);\n\n\ti = 0;\n\tif (s1)\n\t{\n\t\twhile (s1[i])\n\t\t{\n\t\t\tnew_str[i] = s1[i];\n\t\t\ti++;\n\t\t}\n\t}\n\tj = 0;\n\twhile (s2[j])\n\t{\n\t\tnew_str[i + j] = s2[j];\n\t\tj++;\n\t}\n\tnew_str[i + j] = '\\0';\n\treturn (new_str);\n}\nint\tft_strcmp(const char *s1, const char *s2)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n\nint\tft_strncmp(const char *s1, const char *s2, size_t n)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (n == 0)\n\t\treturn (0);\n\twhile (i < n - 1 && s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n",
  "tools/strings/strings2.c": "#include \"cub3d.h\"\n\nchar\t*ft_strdup(char *value)\n{\n\tchar\t*result;\n\tint\t\ti;\n\tint\t\tlen;\n\n\tif (!value)\n\t\treturn (NULL);\n\tlen = ft_strlen(value);\n\tresult = malloc(sizeof(char) * (len + 1));\n\tif (!result)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (value[i] != '\\0')\n\t{\n\t\tresult[i] = value[i];\n\t\ti++;\n\t}\n\tresult[i] = '\\0';\n\treturn (result);\n}\n\nsize_t\tft_strlen(const char *s)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (!s)\n\t\treturn (0);\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\n\nchar\t*ft_substr(char const *s, unsigned int start, size_t len)\n{\n\tsize_t\ti;\n\tchar\t*r;\n\tsize_t\ts_len;\n\n\tif (!s)\n\t\treturn (NULL);\n\ts_len = ft_strlen(s);\n\tif (s_len < start)\n\t\treturn (ft_strdup(\"\"));\n\tif (len > s_len - start)\n\t\tlen = s_len - start;\n\tr = malloc(len + 1);\n\tif (!r)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < len)\n\t{\n\t\tr[i] = s[start + i];\n\t\ti++;\n\t}\n\tr[i] = '\\0';\n\treturn (r);\n}\nint\tft_isdigit(int c)\n{\n\treturn (c >= '0' && c <= '9');\n}",
  "tools/strings/strings3.c": "#include \"cub3d.h\"\n\nstatic int\tcount_digits(int n)\n{\n\tint\tcount;\n\n\tcount = 1;\n\twhile (n / 10)\n\t{\n\t\tn /= 10;\n\t\tcount++;\n\t}\n\treturn (count);\n}\n\nchar\t*ft_itoa(int n)\n{\n\tchar\t\t*str;\n\tlong\t\tnum;\n\tint\t\t\tlen;\n\tint\t\t\tis_negative;\n\n\tnum = n;\n\tis_negative = (num < 0);\n\tif (is_negative)\n\t\tnum = -num;\n\tlen = count_digits(num) + is_negative;\n\tstr = malloc(sizeof(char) * (len + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tstr[len] = '\\0';\n\twhile (len-- > 0)\n\t{\n\t\tstr[len] = '0' + (num % 10);\n\t\tnum /= 10;\n\t\tif (len == 0 && is_negative)\n\t\t\tstr[0] = '-';\n\t}\n\treturn (str);\n}\n\nint ft_atoi(const char *str)\n{\n    long result = 0;\n    int  sign = 1;\n    int  i = 0;\n\n    while (str[i] == ' ' || (str[i] >= '\\t' && str[i] <= '\\r'))\n        i++;\n    if (str[i] == '-' || str[i] == '+')\n    {\n        if (str[i] == '-')\n            sign = -1;\n        i++;\n    }\n    while (str[i] >= '0' && str[i] <= '9')\n    {\n        int digit = str[i] - '0';\n        if (result > (LONG_MAX - digit) / 10)\n        {\n            if (sign == 1)\n                return (INT_MAX);\n            else\n                return (INT_MIN);\n        }\n        result = result * 10 + digit;\n        i++;\n    }\n    result *= sign;\n    if (result > INT_MAX)\n        return INT_MAX;\n    if (result < INT_MIN)\n        return INT_MIN;\n    return (int)result;\n}\n\n\n\nchar\t*ft_strchr(const char *s, int c)\n{\n\twhile (*s)\n\t{\n\t\tif (*s == (char)c)\n\t\t\treturn ((char *)s);\n\t\ts++;\n\t}\n\tif ((char)c == '\\0')\n\t\treturn ((char *)s);\n\treturn (NULL);\n}\n\nvoid free_split(char **arr)\n{\n    int i = 0;\n    if (!arr) return;\n    while (arr[i])\n    {\n        free(arr[i]);\n        i++;\n    }\n    free(arr);\n}\nchar *ft_strtrim_newline(char *s)\n{\n    size_t len;\n    char *trimmed_s;\n\n    if (!s)\n        return NULL;\n    len = ft_strlen(s);\n    while (len > 0 && (s[len - 1] == '\\n' ||\n        s[len - 1] == ' ' || s[len - 1] == '\\r' || s[len - 1] == '\\t'))\n        len--;\n    trimmed_s = gc_substr(s, 0, len);\n    return trimmed_s;\n}"
}